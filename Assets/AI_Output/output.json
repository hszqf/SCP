{
    "batch_id": "modalstack_investigate_panels_02_read_and_hierarchy",
    "results": [
        {
            "id": 1,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: UI/UIPanelRoot\n// Source: Assets/Scripts/UI/UIPanelRoot.cs\n// Version: UI_UIPanelRoot_v2_20260114a\n// Updated for N-task backend:\n// - Each click on 调查/收容 creates a NEW task (NodeTask) and opens AgentPicker bound to that taskId.\n// - This enables multiple investigate tasks and multiple contain tasks (one per containable).\n// - On picker cancel (or close), the newly created task is cancelled to avoid leaving invisible active tasks.\n//\n// Notes:\n// - Busy check still uses GameControllerTaskExt.AreAgentsBusy (global task scan).\n// - Contain requires node.Containables.Count > 0; target selection picks a containable not already targeted by an active contain task when possible.\n// - UI still uses ConfirmDialog for info prompts.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Core;\nusing Data;\nusing UnityEngine;\n\npublic class UIPanelRoot : MonoBehaviour\n{\n    public static UIPanelRoot I { get; private set; }\n\n    [Header(\"Prefabs (请把 Assets/Prefabs/UI 下的文件拖进来)\")]\n    [SerializeField] private HUD hudPrefab; // HUD Prefab\n    [SerializeField] private NodePanelView nodePanelPrefab;\n    [SerializeField] private EventPanel eventPanelPrefab;\n    [SerializeField] private NewsPanel newsPanelPrefab;\n    [SerializeField] private GameObject NewspaperPanelPrefab;\n    [SerializeField] private AgentPickerView agentPickerPrefab;\n    [SerializeField] private ConfirmDialog confirmDialogPrefab;\n    [SerializeField] private GameObject managePanelPrefab; // 管理面板 Prefab（你新建的管理界面）\n    [SerializeField] private RecruitPanel recruitPanelPrefab;\n\n    // --- 运行时实例 (自动生成) ---\n    private HUD _hud;\n    private NodePanelView _nodePanel;\n    private EventPanel _eventPanel;\n    private NewsPanel _newsPanel;\n    private GameObject _newspaperPanelInstance;\n    private AgentPickerView _agentPicker;\n    private ConfirmDialog _confirmDialog;\n    private GameObject _managePanel;\n    private AnomalyManagePanel _managePanelView;\n    private RecruitPanel _recruitPanel;\n\n    private List<GameObject> _modalStack = new List<GameObject>();\n    private bool _confirmDialogOnClosedHooked;\n\n    private string _currentNodeId;\n    private string _manageNodeId; // 当前打开的管理面板所对应的节点（与 NodePanel 的当前节点解耦）\n    private string _pickerTaskId;\n\n    public string CurrentNodeId => _currentNodeId;\n    public string ManageNodeId => _manageNodeId;\n\n    private void Awake()\n    {\n        I = this;\n    }\n\n    private void Start()\n    {\n        InitHUD();\n    }\n\n    private void OnEnable()\n    {\n        if (GameController.I != null) GameController.I.OnStateChanged += OnGameStateChanged;\n    }\n\n    private void OnDisable()\n    {\n        if (GameController.I != null) GameController.I.OnStateChanged -= OnGameStateChanged;\n    }\n\n    void InitHUD()\n    {\n        if (_hud) return;\n        if (hudPrefab)\n        {\n            _hud = Instantiate(hudPrefab, transform);\n            // HUD should be at the bottom so panels can cover it\n            _hud.transform.SetAsFirstSibling();\n        }\n    }\n\n    void OnGameStateChanged()\n    {\n        // 1. If node panel is open, refresh it\n        if (_nodePanel != null && _nodePanel.gameObject.activeSelf)\n            _nodePanel.Refresh();\n\n        // 2. Try auto-open event\n        TryAutoOpenEvent();\n    }\n\n    // ================== NODE PANEL ==================\n\n    public void OpenNode(string nodeId)\n    {\n        _currentNodeId = nodeId;\n\n        EnsureNodePanel();\n        _nodePanel.Show(nodeId);\n        if (_nodePanel) PushModal(_nodePanel.gameObject, \"OpenNode\");\n    }\n\n    public void CloseNode()\n    {\n        ForceCancelPickerIfNeeded(true);\n        if (_nodePanel) _nodePanel.Hide();\n        if (_nodePanel) PopModal(_nodePanel.gameObject, \"CloseNode\");\n        _currentNodeId = null;\n        // 注意：不要清理 _manageNodeId。管理面板可能仍在打开，需要保持其上下文。\n    }\n\n    public void RefreshNodePanel() // 兼容旧接口\n    {\n        if (_nodePanel && _nodePanel.gameObject.activeSelf) _nodePanel.Refresh();\n    }\n\n    void EnsureNodePanel()\n    {\n        if (_nodePanel) return;\n        if (!nodePanelPrefab) { Debug.LogError(\"NodePanelPrefab 未配置！\"); return; }\n\n        _nodePanel = Instantiate(nodePanelPrefab, transform);\n        // Inject callbacks\n        _nodePanel.Init(\n            onInvestigate: () => OpenInvestigateAssignPanel(),\n            onContain: () => OpenContainAssignPanel(),\n            onClose: () => CloseNode()\n        );\n    }\n\n    // ================== CONFIRM DIALOG ==================\n\n    void EnsureConfirmDialog()\n    {\n        if (_confirmDialog) return;\n        if (!confirmDialogPrefab) return;\n        _confirmDialog = Instantiate(confirmDialogPrefab, transform);\n        HookConfirmDialogOnClosed();\n    }\n\n    void ShowInfo(string title, string message)\n    {\n        EnsureConfirmDialog();\n        if (_confirmDialog)\n        {\n            _confirmDialog.ShowInfo(title, message);\n            _confirmDialog.transform.SetAsLastSibling();\n            PushModal(_confirmDialog.gameObject, \"ConfirmDialog.ShowInfo\");\n        }\n        else\n        {\n            Debug.LogWarning($\"[UIPanelRoot] ConfirmDialog prefab not set. Info: {title} / {message}\");\n        }\n    }\n\n    // ================== ASSIGNMENT PANEL (Investigate / Contain) ==================\n\n    void OpenInvestigateAssignPanel()\n    {\n        if (GameController.I == null) return;\n        if (string.IsNullOrEmpty(_currentNodeId)) return;\n\n        EnsureManagePanel();\n        if (!_managePanelView) return;\n\n        var gc = GameController.I;\n        var node = gc.GetNode(_currentNodeId);\n        if (node == null)\n        {\n            ShowInfo(\"派遣失败\", \"节点不存在\");\n            return;\n        }\n\n        var registry = DataRegistry.Instance;\n        var targets = BuildInvestigateTargets(node, registry, gc.State?.NewsLog);\n        var (slotsMin, slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Investigate, 1, int.MaxValue);\n\n        _manageNodeId = _currentNodeId;\n        if (_managePanel) _managePanel.SetActive(true);\n        _managePanel.transform.SetAsLastSibling();\n        _managePanelView.ShowGeneric(\n            header: $\"Investigate | {_currentNodeId}\",\n            hint: \"选择新闻线索（可选）并派遣干员\",\n            targets: targets,\n            agentSlotsMin: slotsMin,\n            agentSlotsMax: slotsMax,\n            onConfirm: (targetId, agentIds) =>\n            {\n                if (agentIds == null || agentIds.Count == 0)\n                {\n                    ShowInfo(\"派遣失败\", \"未选择干员\");\n                    return;\n                }\n\n                if (GameControllerTaskExt.AreAgentsBusy(gc, agentIds, null))\n                {\n                    ShowInfo(\"派遣失败\", \"部分干员正在其他任务执行中\");\n                    return;\n                }\n\n                var task = gc.CreateInvestigateTask(_currentNodeId);\n                if (task == null)\n                {\n                    ShowInfo(\"派遣失败\", \"创建任务失败\");\n                    return;\n                }\n\n                string targetNewsId = string.IsNullOrEmpty(targetId) ? null : targetId;\n                task.TargetNewsId = targetNewsId;\n\n                string sourceAnomalyId = null;\n                if (!string.IsNullOrEmpty(targetNewsId))\n                {\n                    var news = gc.State?.NewsLog?.FirstOrDefault(n => n != null && n.Id == targetNewsId);\n                    sourceAnomalyId = news?.SourceAnomalyId;\n                    task.SourceAnomalyId = sourceAnomalyId;\n                    Debug.Log($\"[InvestigateBindNews] taskId={task.Id} newsId={targetNewsId} srcAnom={sourceAnomalyId} nodeId={_currentNodeId}\");\n                }\n\n                gc.AssignTask(task.Id, agentIds);\n                _managePanelView.Hide();\n                RefreshNodePanel();\n            },\n            modeLabel: \"Investigate\"\n        );\n    }\n\n    void OpenContainAssignPanel()\n    {\n        if (GameController.I == null) return;\n        if (string.IsNullOrEmpty(_currentNodeId)) return;\n\n        EnsureManagePanel();\n        if (!_managePanelView) return;\n\n        var gc = GameController.I;\n        var node = gc.GetNode(_currentNodeId);\n        if (node == null)\n        {\n            ShowInfo(\"派遣失败\", \"节点不存在\");\n            return;\n        }\n\n        var registry = DataRegistry.Instance;\n        var targets = BuildContainTargets(node, registry);\n        var (slotsMin, slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Contain, 1, int.MaxValue);\n\n        string hint = targets.Count == 0\n            ? \"无已确认异常：请先调查（随意或针对新闻）以发现异常\"\n            : \"选择要收容的异常并派遣干员\";\n\n        _manageNodeId = _currentNodeId;\n        if (_managePanel) _managePanel.SetActive(true);\n        _managePanel.transform.SetAsLastSibling();\n        _managePanelView.ShowGeneric(\n            header: $\"Contain | {_currentNodeId}\",\n            hint: hint,\n            targets: targets,\n            agentSlotsMin: slotsMin,\n            agentSlotsMax: slotsMax,\n            onConfirm: (targetAnomalyId, agentIds) =>\n            {\n                if (string.IsNullOrEmpty(targetAnomalyId))\n                {\n                    ShowInfo(\"派遣失败\", \"未选择收容目标\");\n                    return;\n                }\n\n                if (agentIds == null || agentIds.Count == 0)\n                {\n                    ShowInfo(\"派遣失败\", \"未选择干员\");\n                    return;\n                }\n\n                if (GameControllerTaskExt.AreAgentsBusy(gc, agentIds, null))\n                {\n                    ShowInfo(\"派遣失败\", \"部分干员正在其他任务执行中\");\n                    return;\n                }\n\n                string containableId = EnsureContainableForAnomaly(node, registry, targetAnomalyId);\n                var task = gc.CreateContainTask(_currentNodeId, containableId);\n                if (task == null)\n                {\n                    ShowInfo(\"派遣失败\", \"创建任务失败\");\n                    return;\n                }\n\n                task.SourceAnomalyId = targetAnomalyId;\n                gc.AssignTask(task.Id, agentIds);\n                _managePanelView.Hide();\n                RefreshNodePanel();\n            },\n            modeLabel: \"Contain\"\n        );\n    }\n\n    private List<AnomalyManagePanel.TargetEntry> BuildInvestigateTargets(NodeState node, DataRegistry registry, List<NewsInstance> newsLog)\n    {\n        var targets = new List<AnomalyManagePanel.TargetEntry>\n        {\n            new AnomalyManagePanel.TargetEntry\n            {\n                id = \"\",\n                title = \"随意调查\",\n                subtitle = \"不针对任何新闻（较慢）\",\n                disabled = false\n            }\n        };\n\n        if (newsLog == null) return targets;\n\n        foreach (var news in newsLog)\n        {\n            if (news == null) continue;\n            if (!string.Equals(news.NodeId, node.Id, StringComparison.OrdinalIgnoreCase)) continue;\n            if (news.IsResolved) continue;\n\n            var def = registry.GetNewsDefById(news.NewsDefId);\n            string title = def?.title ?? news.NewsDefId ?? \"\";\n            string subtitle = !string.IsNullOrEmpty(news.SourceAnomalyId)\n                ? $\"线索指向：{news.SourceAnomalyId}\"\n                : \"线索来源未知\";\n\n            targets.Add(new AnomalyManagePanel.TargetEntry\n            {\n                id = news.Id,\n                title = title,\n                subtitle = subtitle,\n                disabled = false\n            });\n        }\n\n        return targets;\n    }\n\n    private List<AnomalyManagePanel.TargetEntry> BuildContainTargets(NodeState node, DataRegistry registry)\n    {\n        var targets = new List<AnomalyManagePanel.TargetEntry>();\n        var known = node?.KnownAnomalyDefIds;\n        if (known == null || known.Count == 0) return targets;\n\n        // Use intersection: Known ∩ ActiveAnomalyIds (to avoid containing anomalies that have disappeared)\n        var activeSet = new HashSet<string>(node.ActiveAnomalyIds ?? new List<string>());\n\n        foreach (var anomalyId in known)\n        {\n            if (string.IsNullOrEmpty(anomalyId)) continue;\n            if (!activeSet.Contains(anomalyId)) continue;  // Only include if still active\n\n            var def = registry.AnomaliesById.TryGetValue(anomalyId, out var anomalyDef) ? anomalyDef : null;\n            string title = def?.name ?? anomalyId;\n\n            targets.Add(new AnomalyManagePanel.TargetEntry\n            {\n                id = anomalyId,\n                title = title,\n                subtitle = null,\n                disabled = false\n            });\n        }\n\n        return targets;\n    }\n\n    private string EnsureContainableForAnomaly(NodeState node, DataRegistry registry, string anomalyId)\n    {\n        if (node == null || string.IsNullOrEmpty(anomalyId)) return null;\n        node.KnownAnomalyDefIds ??= new List<string>();\n        if (!node.KnownAnomalyDefIds.Contains(anomalyId))\n            node.KnownAnomalyDefIds.Add(anomalyId);\n        return anomalyId;\n    }\n\n    // ================== MANAGE PANEL ==================\n\n    void EnsureManagePanel()\n    {\n        if (_managePanel) return;\n        if (!managePanelPrefab)\n        {\n            Debug.LogWarning(\"[UIPanelRoot] managePanelPrefab 未配置！\");\n            return;\n        }\n        _managePanel = Instantiate(managePanelPrefab, transform);\n        _managePanelView = _managePanel.GetComponent<AnomalyManagePanel>();\n        _managePanel.SetActive(false);\n    }\n\n    // 由 NodePanel 的“管理”按钮调用（推荐：传入当前节点 id）\n    public void OpenManage(string nodeId)\n    {\n        _manageNodeId = nodeId;\n        OpenManage();\n    }\n\n    // 兼容旧调用：若未传 nodeId，则默认使用当前打开的节点\n    public void OpenManage()\n    {\n        EnsureManagePanel();\n        if (_managePanel)\n        {\n            if (_managePanelView) _managePanelView.ShowForNode(_manageNodeId);\n            _managePanel.SetActive(true);\n            if (_managePanelView) _managePanelView.ShowForNode(_manageNodeId);\n            _managePanel.transform.SetAsLastSibling();\n        }\n    }\n\n    public void CloseManage()\n    {\n        if (_managePanel) _managePanel.SetActive(false);\n    }\n\n    // ================== OTHERS ==================\n\n    public void OpenNews()\n    {\n        OpenNewspaperPanel();\n    }\n\n    void EnsureNewspaperPanel()\n    {\n        if (_newspaperPanelInstance) return;\n        if (!NewspaperPanelPrefab)\n        {\n            Debug.LogError(\"[UIPanelRoot] NewspaperPanelPrefab 未配置！\");\n            return;\n        }\n\n        _newspaperPanelInstance = Instantiate(NewspaperPanelPrefab, transform);\n        if (_newspaperPanelInstance.GetComponent<UI.NewspaperPanelView>() == null)\n        {\n            _newspaperPanelInstance.AddComponent<UI.NewspaperPanelView>();\n        }\n        _newspaperPanelInstance.SetActive(false);\n    }\n\n    public void OpenNewspaperPanel()\n    {\n        EnsureNewspaperPanel();\n        if (_newspaperPanelInstance)\n        {\n            _newspaperPanelInstance.SetActive(true);\n            var view = _newspaperPanelInstance.GetComponent<UI.NewspaperPanelView>();\n            if (view != null) view.Render();\n            _newspaperPanelInstance.transform.SetAsLastSibling();\n            PushModal(_newspaperPanelInstance, \"OpenNewspaperPanel\");\n        }\n    }\n\n    public void HideNewspaperPanel()\n    {\n        if (_newspaperPanelInstance)\n        {\n            _newspaperPanelInstance.SetActive(false);\n            PopModal(_newspaperPanelInstance, \"HideNewspaperPanel\");\n        }\n    }\n\n    // ================== RECRUIT ==================\n\n    void EnsureRecruitPanel()\n    {\n        if (_recruitPanel) return;\n        if (!recruitPanelPrefab)\n        {\n            Debug.LogError(\"[UIPanelRoot] recruitPanelPrefab 未配置，无法打开 RecruitPanel。\");\n            return;\n        }\n\n        _recruitPanel = Instantiate(recruitPanelPrefab, transform);\n\n        if (_recruitPanel) _recruitPanel.gameObject.SetActive(false);\n    }\n\n    public void OpenRecruit()\n    {\n        EnsureRecruitPanel();\n        if (_recruitPanel)\n        {\n            _recruitPanel.Show();\n            _recruitPanel.transform.SetAsLastSibling();\n        }\n    }\n\n    public void CloseRecruit()\n    {\n        if (_recruitPanel) _recruitPanel.Hide();\n    }\n\n    public void OpenNodeEvent(string nodeId)\n    {\n        if (GameController.I == null || string.IsNullOrEmpty(nodeId)) return;\n        var node = GameController.I.GetNode(nodeId);\n        if (node == null || node.PendingEvents == null || node.PendingEvents.Count == 0) return;\n\n        if (!_eventPanel && eventPanelPrefab) _eventPanel = Instantiate(eventPanelPrefab, transform);\n        if (!_eventPanel) return;\n\n        var ev = node.PendingEvents[0];\n        Debug.Log($\"[EventUI] OpenNodeEvent node={nodeId} eventInstanceId={ev.EventInstanceId} pending={node.PendingEvents.Count}\");\n        _eventPanel.Show(ev, optionId =>\n        {\n            var res = GameController.I.ResolveEvent(nodeId, ev.EventInstanceId, optionId);\n            return res.text;\n        }, onClose: null);\n    }\n\n    void TryAutoOpenEvent()\n    {\n        // Auto-open is disabled. Events should only be opened via manual entry points.\n        return;\n    }\n\n    private bool TryGetFirstPendingEvent(out string nodeId, out EventInstance ev)\n    {\n        nodeId = null;\n        ev = null;\n\n        foreach (var n in GameController.I.State.Nodes)\n        {\n            if (n?.PendingEvents == null || n.PendingEvents.Count == 0) continue;\n            ev = n.PendingEvents[0];\n            nodeId = n.Id;\n            return !string.IsNullOrEmpty(nodeId) && ev != null;\n        }\n\n        return false;\n    }\n\n    public void CloseEvent()\n    {\n        if (_eventPanel) _eventPanel.gameObject.SetActive(false);\n    }\n\n    // ================== COMPATIBILITY ==================\n\n    public void AssignInvestigate_A1() => Debug.Log(\"Old button clicked\");\n    public void AssignInvestigate_A2() => Debug.Log(\"Old button clicked\");\n    public void AssignInvestigate_A3() => Debug.Log(\"Old button clicked\");\n    public void AssignContain_A1() => Debug.Log(\"Old button clicked\");\n    public void AssignContain_A2() => Debug.Log(\"Old button clicked\");\n    public void AssignContain_A3() => Debug.Log(\"Old button clicked\");\n\n    public void CloseAll()\n    {\n        ForceCancelPickerIfNeeded(true);\n        CloseNode();\n        CloseEvent();\n        CloseManage();\n        CloseRecruit();\n        if (_newsPanel) _newsPanel.Hide();\n\n        if (_confirmDialog) _confirmDialog.Hide();\n    }\n\n    // ================== HELPERS ==================\n    void ForceCancelPickerIfNeeded(bool hidePicker = true)\n    {\n        var taskId = _pickerTaskId;\n        _pickerTaskId = null;\n\n        if (!string.IsNullOrEmpty(taskId) && GameController.I != null)\n        {\n            GameController.I.CancelOrRetreatTask(taskId);\n            GameControllerTaskExt.LogBusySnapshot(GameController.I, $\"UIPanelRoot.ForceCancelPickerIfNeeded(task:{taskId})\");\n            RefreshNodePanel();\n        }\n\n        if (hidePicker && _agentPicker)\n        {\n            GameControllerTaskExt.LogBusySnapshot(GameController.I, \"UIPanelRoot.ForceCancelPickerIfNeeded(hidePicker)\");\n            _agentPicker.Hide();\n        }\n    }\n\n    // ================== MODAL STACK ==================\n\n    private void PushModal(GameObject panel, string reason)\n    {\n        if (_modalStack == null) _modalStack = new List<GameObject>();\n\n        if (panel != null)\n        {\n            _modalStack.Remove(panel);\n            _modalStack.Add(panel);\n        }\n\n        LogModalStack(\"Push\", panel, reason);\n    }\n\n    private void PopModal(GameObject panel, string reason)\n    {\n        if (_modalStack == null) _modalStack = new List<GameObject>();\n\n        if (panel != null)\n        {\n            _modalStack.Remove(panel);\n        }\n\n        LogModalStack(\"Pop\", panel, reason);\n    }\n\n    private void RefreshModalStack(string reason, GameObject relatedPanel = null, bool sortBySiblingIndex = false)\n    {\n        if (_modalStack == null) _modalStack = new List<GameObject>();\n\n        _modalStack.RemoveAll(p => p == null);\n\n        if (sortBySiblingIndex)\n        {\n            _modalStack.Sort((a, b) => a.transform.GetSiblingIndex().CompareTo(b.transform.GetSiblingIndex()));\n        }\n\n        LogModalStack(\"Refresh\", relatedPanel, reason);\n    }\n\n    private void LogModalStack(string action, GameObject panel, string reason)\n    {\n        var panelName = panel != null ? panel.name : \"ALL\";\n        var safeReason = string.IsNullOrEmpty(reason) ? \"(no-reason)\" : reason;\n        Debug.Log($\"[ModalStack] action={action} panel={panelName} count={_modalStack?.Count ?? 0} reason={safeReason}\");\n    }\n\n    private void HookConfirmDialogOnClosed()\n    {\n        if (_confirmDialog == null || _confirmDialogOnClosedHooked) return;\n\n        _confirmDialog.OnClosed += HandleConfirmDialogClosed;\n        _confirmDialogOnClosedHooked = true;\n    }\n\n    private void HandleConfirmDialogClosed()\n    {\n        PopModal(_confirmDialog ? _confirmDialog.gameObject : null, \"ConfirmDialog.OnClosed\");\n    }\n\n    // Pick a containable that is not already targeted by an active containment task when possible.\n    string PickNextContainableId(NodeState node)\n    {\n        if (node == null || node.KnownAnomalyDefIds == null || node.KnownAnomalyDefIds.Count == 0) return null;\n\n        var activeTargets = (node.Tasks == null)\n            ? new HashSet<string>()\n            : new HashSet<string>(node.Tasks\n                .Where(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Contain)\n                .Select(t => t.SourceAnomalyId)\n                .Where(x => !string.IsNullOrEmpty(x)));\n\n        foreach (var defId in node.KnownAnomalyDefIds)\n        {\n            if (!activeTargets.Contains(defId)) return defId;\n        }\n\n        // Fallback: allow multiple tasks for same anomaly if all are already targeted.\n        return node.KnownAnomalyDefIds[0];\n    }\n}\n// </EXPORT_BLOCK>"
        },
        {
            "id": 2,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Assets/Scripts/UI/NodePanelView.cs\n// N-task model compatible (Core.NodeState.Tasks)\n//\n// UI behavior:\n// 1) If a scrollable task list exists in the prefab (Content + Row template), render ALL tasks as rows.\n// 2) Otherwise, fall back to the legacy 2 summary cards (调查 / 收容) by selecting one representative task per type.\n//\n// Required prefab names for full task list (recommended):\n// - TaskListScroll (ScrollRect)\n//   - Viewport\n//     - Content\n//       - TaskRowTemplate (inactive)\n//          - Title (TMP_Text)\n//          - Status (TMP_Text)\n//          - People (TMP_Text)\n//          - Btn_Action (Button)\n//             - Label (TMP_Text)\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Core;\nusing Data;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class NodePanelView : MonoBehaviour\n{\n    [Header(\"UI Components\")]\n    [SerializeField] private TMP_Text titleText;\n    [SerializeField] private TMP_Text statusText;\n    [SerializeField] private TMP_Text progressText;\n    [SerializeField] private TMP_Text eventCountText;\n\n    [Header(\"Buttons\")]\n    [SerializeField] private Button investigateButton;\n    [SerializeField] private Button containButton;\n    [SerializeField] private Button manageButton; // 收容后管理（打开管理面板）\n    [SerializeField] private Button processEventButton; // 处理事件\n    [SerializeField] private Button closeButton;\n    [SerializeField] private Button backgroundButton; // 蒙版按钮\n\n    // 回调函数\n    private Action _onInvestigate;\n    private Action _onContain;\n    private Action _onClose;\n\n    // Cached root (for opening manage panel without changing Init signature)\n    private UIPanelRoot _uiRoot;\n\n    private string _nodeId;\n\n    // --- Task Status UI (read-only summary cards) ---\n    private bool _taskUiCached;\n    private Transform _invCardRoot;\n    private Transform _conCardRoot;\n    private TMP_Text _invTitle;\n    private TMP_Text _invStatus;\n    private TMP_Text _invPeople;\n\n    private TMP_Text _conTitle;\n    private TMP_Text _conStatus;\n    private TMP_Text _conPeople;\n\n    // --- Task List UI (scrollable) ---\n    private bool _taskListCached;\n    private Transform _taskListContent;\n    private GameObject _taskRowTemplate;\n    private readonly List<GameObject> _taskRowInstances = new();\n    private readonly Dictionary<string, float> _rowConfirmUntil = new();\n\n    // --- Task Card / Row Action Buttons ---\n    private enum TaskActionMode { None, Cancel, Retreat }\n\n    private Button _invActionBtn;\n    private TMP_Text _invActionLabel;\n    private TaskActionMode _invActionMode = TaskActionMode.None;\n    private float _invConfirmUntil = 0f;\n\n    private Button _conActionBtn;\n    private TMP_Text _conActionLabel;\n    private TaskActionMode _conActionMode = TaskActionMode.None;\n    private float _conConfirmUntil = 0f;\n\n    // Representative task ids for current refresh\n    private string _invTaskId;\n    private string _conTaskId;\n\n\n    // Track if contain button is disabled and why\n    private bool _containDisabledForNoAnomalies = false;\n    // Track current containables state for guard checks\n    // Track last statusText for hint reset\n    private string _lastStatusText = null;\n\n    private const float EPS = 0.0001f;\n\n    public void Init(Action onInvestigate, Action onContain, Action onClose)\n    {\n        // Cache UIPanelRoot once\n        if (_uiRoot == null) _uiRoot = FindFirstObjectByType<UIPanelRoot>();\n        _onInvestigate = onInvestigate;\n        _onContain = onContain;\n        _onClose = onClose;\n\n        if (investigateButton)\n        {\n            investigateButton.onClick.RemoveAllListeners();\n            investigateButton.onClick.AddListener(() => _onInvestigate?.Invoke());\n        }\n\n        if (containButton)\n        {\n            containButton.onClick.RemoveAllListeners();\n            containButton.onClick.AddListener(() => _onContain?.Invoke());\n        }\n\n        if (manageButton)\n        {\n            manageButton.onClick.RemoveAllListeners();\n            manageButton.onClick.AddListener(() =>\n            {\n                // Manage panel is global (not per-node). If missing, do nothing.\n                _uiRoot?.OpenManage(_nodeId);\n            });\n        }\n\n        if (!processEventButton)\n        {\n            var btnT = FindDeepChild(transform, \"Btn_ProcessEvent\");\n            if (btnT != null) processEventButton = btnT.GetComponent<Button>();\n        }\n\n        if (processEventButton)\n        {\n            processEventButton.onClick.RemoveAllListeners();\n            processEventButton.onClick.AddListener(() => _uiRoot?.OpenNodeEvent(_nodeId));\n        }\n\n        if (closeButton)\n        {\n            closeButton.onClick.RemoveAllListeners();\n            closeButton.onClick.AddListener(() => _onClose?.Invoke());\n        }\n\n        // 蒙版点击 = 关闭\n        if (backgroundButton)\n        {\n            backgroundButton.onClick.RemoveAllListeners();\n            backgroundButton.onClick.AddListener(() => _onClose?.Invoke());\n        }\n\n        CacheTaskStatusUIIfNeeded();\n        CacheTaskListUIIfNeeded();\n    }\n\n    public void Show(string nodeId)\n    {\n        _nodeId = nodeId;\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n\n        CacheTaskStatusUIIfNeeded();\n        CacheTaskListUIIfNeeded();\n        Refresh();\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n    }\n\n    public void Refresh()\n    {\n        if (string.IsNullOrEmpty(_nodeId)) return;\n        if (GameController.I == null) return;\n\n        var n = GameController.I.GetNode(_nodeId);\n        if (n == null) return;\n\n        if (!eventCountText)\n        {\n            var evtT = FindDeepChild(transform, \"EventCountText\");\n            if (evtT != null) eventCountText = evtT.GetComponent<TMP_Text>();\n        }\n\n        if (!processEventButton)\n        {\n            var btnT = FindDeepChild(transform, \"Btn_ProcessEvent\");\n            if (btnT != null) processEventButton = btnT.GetComponent<Button>();\n        }\n\n        if (processEventButton && processEventButton.onClick.GetPersistentEventCount() == 0)\n        {\n            processEventButton.onClick.RemoveAllListeners();\n            processEventButton.onClick.AddListener(() => _uiRoot?.OpenNodeEvent(_nodeId));\n        }\n\n        if (titleText) titleText.text = n.Name;\n\n\n        string s = $\"{n.Status}\";\n        if (n.HasAnomaly) s += \" <color=red>[ANOMALY]</color>\";\n        if (n.HasPendingEvent) s += \" <color=#FFA500>[ATTENTION]</color>\";\n\n        // 记录原始状态文本\n        _lastStatusText = s;\n\n\n        // 统一口径：可收容 = 已发现 - 已收容\n        int containableCount = GetContainableCount(n);\n        bool hasContainables = containableCount > 0;\n\n        UpdateDispatchButtons(n, containableCount, hasContainables);\n\n        // Add hint if contain button is disabled due to no anomalies\n        if (_containDisabledForNoAnomalies)\n        {\n            s += \" <color=#FFAA00>[请先调查发现异常]</color>\";\n        }\n\n        if (statusText) statusText.text = s;\n\n        UpdateManageButton(n);\n\n        int pendingEvents = n.HasPendingEvent ? n.PendingEvents.Count : 0;\n\n        if (eventCountText)\n        {\n            eventCountText.text = pendingEvents > 0 ? $\"待处理事件：{pendingEvents}\" : \"待处理事件：0\";\n        }\n\n        if (processEventButton)\n        {\n            processEventButton.gameObject.SetActive(pendingEvents > 0);\n            processEventButton.interactable = pendingEvents > 0;\n        }\n\n        if (progressText)\n        {\n            int invActive = n.Tasks?.Count(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Investigate) ?? 0;\n            int conActive = n.Tasks?.Count(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Contain) ?? 0;\n            int manActive = n.Tasks?.Count(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Manage) ?? 0;\n            int containables = GetContainableCount(n);\n\n            int busy = 0;\n            if (n.Tasks != null)\n            {\n                busy = n.Tasks\n                    .Where(t => t != null && t.State == TaskState.Active && t.AssignedAgentIds != null)\n                    .SelectMany(t => t.AssignedAgentIds)\n                    .Distinct()\n                    .Count();\n            }\n\n            int managed = n.ManagedAnomalies != null ? n.ManagedAnomalies.Count : 0;\n            int neg = GameController.I.State.NegEntropy;\n            progressText.text = $\"Tasks: 调查 {invActive}, 收容 {conActive}, 管理 {manActive} | 可收容 {containables} | Busy {busy} | 已收藏 {managed} | 负熵 {neg} | 事件 {pendingEvents}\";\n        }\n\n        CacheTaskListUIIfNeeded();\n        if (RefreshTaskListIfPresent(n))\n        {\n            // Optional: if list exists, you may want to hide legacy summary cards to reduce clutter.\n            // Keep them visible by default to avoid layout surprises.\n            return;\n        }\n\n        CacheTaskStatusUIIfNeeded();\n        RefreshTaskCardsSummary(n);\n    }\n\n    // ----------------------\n    // Task Status UI helpers (summary cards)\n    // ----------------------\n\n    private void CacheTaskStatusUIIfNeeded()\n    {\n        if (_taskUiCached) return;\n\n        _invCardRoot = FindDeepChild(transform, \"TaskCard_Investigate\");\n        if (_invCardRoot != null)\n        {\n            _invTitle = GetTmp(_invCardRoot, \"Title\");\n            _invStatus = GetTmp(_invCardRoot, \"Status\");\n            _invPeople = GetTmp(_invCardRoot, \"People\");\n\n            var btnT = _invCardRoot.Find(\"Btn_Action\");\n            if (btnT != null)\n            {\n                _invActionBtn = btnT.GetComponent<Button>();\n                _invActionLabel = GetTmp(btnT, \"Label\");\n                if (_invActionBtn)\n                {\n                    _invActionBtn.onClick.RemoveAllListeners();\n                    _invActionBtn.onClick.AddListener(OnInvActionClicked);\n                }\n            }\n        }\n\n        _conCardRoot = FindDeepChild(transform, \"TaskCard_Contain\");\n        if (_conCardRoot != null)\n        {\n            _conTitle = GetTmp(_conCardRoot, \"Title\");\n            _conStatus = GetTmp(_conCardRoot, \"Status\");\n            _conPeople = GetTmp(_conCardRoot, \"People\");\n\n            var btnT = _conCardRoot.Find(\"Btn_Action\");\n            if (btnT != null)\n            {\n                _conActionBtn = btnT.GetComponent<Button>();\n                _conActionLabel = GetTmp(btnT, \"Label\");\n                if (_conActionBtn)\n                {\n                    _conActionBtn.onClick.RemoveAllListeners();\n                    _conActionBtn.onClick.AddListener(OnConActionClicked);\n                }\n            }\n        }\n\n        _taskUiCached = (_invCardRoot != null || _conCardRoot != null);\n    }\n\n    private void RefreshTaskCardsSummary(NodeState node)\n    {\n        // If task cards are not present (prefab not patched / different variant), do nothing.\n        if (_invTitle == null && _invStatus == null && _invPeople == null && _conTitle == null && _conStatus == null && _conPeople == null)\n            return;\n\n        if (_invTitle) _invTitle.text = \"调查\";\n        if (_conTitle) _conTitle.text = \"收容\";\n\n        var tasks = node.Tasks ?? new List<NodeTask>();\n        var inv = tasks.Where(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Investigate).ToList();\n        var con = tasks.Where(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Contain).ToList();\n\n        // Representative task selection:\n        // 1) Prefer tasks with squad.\n        // 2) Among squad tasks, prefer \"not started\" (progress==0) so user can see/Cancel the newest assignment.\n        // 3) Then CreatedDay desc -> Progress desc.\n        NodeTask invMain = inv\n            .OrderByDescending(t => t.AssignedAgentIds != null && t.AssignedAgentIds.Count > 0)\n            .ThenBy(t => (t.Progress > EPS) ? 1 : 0)\n            .ThenByDescending(t => t.CreatedDay)\n            .ThenByDescending(t => t.Progress)\n            .FirstOrDefault();\n\n        NodeTask conMain = con\n            .OrderByDescending(t => t.AssignedAgentIds != null && t.AssignedAgentIds.Count > 0)\n            .ThenBy(t => (t.Progress > EPS) ? 1 : 0)\n            .ThenByDescending(t => t.CreatedDay)\n            .ThenByDescending(t => t.Progress)\n            .FirstOrDefault();\n\n        _invTaskId = invMain?.Id;\n        _conTaskId = conMain?.Id;\n\n        int containablesCount = GetContainableCount(node);\n\n        // Investigate card\n        if (_invStatus)\n        {\n            if (invMain == null)\n            {\n                _invStatus.text = \"状态：可调查\";\n            }\n            else\n            {\n                bool hasSquad = invMain.AssignedAgentIds != null && invMain.AssignedAgentIds.Count > 0;\n                if (hasSquad && invMain.Progress <= EPS) _invStatus.text = \"状态：待开始\";\n                else if (hasSquad) _invStatus.text = $\"状态：进行中（{(int)(GetTaskProgress01(invMain) * 100)}%）\";\n                else _invStatus.text = \"状态：未指派\";\n\n                if (inv.Count > 1) _invStatus.text += $\"（+{inv.Count - 1}）\";\n            }\n        }\n\n        if (_invPeople)\n        {\n            int c = (invMain != null && invMain.AssignedAgentIds != null) ? invMain.AssignedAgentIds.Count : 0;\n            _invPeople.text = $\"人员：{c}人\";\n        }\n\n        // Contain card\n        if (_conStatus)\n        {\n            if (conMain != null)\n            {\n                bool hasSquad = conMain.AssignedAgentIds != null && conMain.AssignedAgentIds.Count > 0;\n                if (hasSquad && conMain.Progress <= EPS) _conStatus.text = \"状态：待开始\";\n                else if (hasSquad) _conStatus.text = $\"状态：进行中（{(int)(GetTaskProgress01(conMain) * 100)}%）\";\n                else _conStatus.text = \"状态：未指派\";\n\n                if (con.Count > 1) _conStatus.text += $\"（+{con.Count - 1}）\";\n            }\n            else if (containablesCount > 0)\n            {\n                _conStatus.text = containablesCount == 1 ? \"状态：可收容\" : $\"状态：可收容（{containablesCount}）\";\n            }\n            else\n            {\n                _conStatus.text = \"状态：未指派\";\n            }\n        }\n\n        if (_conPeople)\n        {\n            if (conMain != null)\n            {\n                int c = (conMain.AssignedAgentIds != null) ? conMain.AssignedAgentIds.Count : 0;\n\n                string targetName = ResolveContainableName(node, conMain.SourceAnomalyId);\n                _conPeople.text = string.IsNullOrEmpty(targetName)\n                    ? $\"人员：{c}人\"\n                    : $\"目标：{targetName}\\n人员：{c}人\";\n            }\n            else if (containablesCount > 0)\n            {\n                string targetName = ResolveContainableName(node, null);\n                _conPeople.text = string.IsNullOrEmpty(targetName)\n                    ? \"目标：可收容\\n人员：0人\"\n                    : $\"目标：{targetName}\\n人员：0人\";\n            }\n            else\n            {\n                _conPeople.text = \"人员：0人\";\n            }\n        }\n\n        UpdateActionButtons(invMain, conMain);\n    }\n\n    private void UpdateActionButtons(NodeTask invTask, NodeTask conTask)\n    {\n        // Investigate action\n        if (_invActionBtn != null)\n        {\n            bool show = invTask != null && invTask.State == TaskState.Active && invTask.AssignedAgentIds != null && invTask.AssignedAgentIds.Count > 0;\n            if (show)\n            {\n                _invActionMode = (invTask.Progress > EPS) ? TaskActionMode.Retreat : TaskActionMode.Cancel;\n                _invActionBtn.gameObject.SetActive(true);\n                if (_invActionLabel)\n                {\n                    _invActionLabel.text = (_invActionMode == TaskActionMode.Cancel)\n                        ? \"取消\"\n                        : (Time.unscaledTime <= _invConfirmUntil ? \"确认撤退\" : \"撤退\");\n                }\n            }\n            else\n            {\n                _invActionMode = TaskActionMode.None;\n                _invConfirmUntil = 0f;\n                _invActionBtn.gameObject.SetActive(false);\n            }\n        }\n\n        // Contain action\n        if (_conActionBtn != null)\n        {\n            bool show = conTask != null && conTask.State == TaskState.Active && conTask.AssignedAgentIds != null && conTask.AssignedAgentIds.Count > 0;\n            if (show)\n            {\n                _conActionMode = (conTask.Progress > EPS) ? TaskActionMode.Retreat : TaskActionMode.Cancel;\n                _conActionBtn.gameObject.SetActive(true);\n                if (_conActionLabel)\n                {\n                    _conActionLabel.text = (_conActionMode == TaskActionMode.Cancel)\n                        ? \"取消\"\n                        : (Time.unscaledTime <= _conConfirmUntil ? \"确认撤退\" : \"撤退\");\n                }\n            }\n            else\n            {\n                _conActionMode = TaskActionMode.None;\n                _conConfirmUntil = 0f;\n                _conActionBtn.gameObject.SetActive(false);\n            }\n        }\n    }\n\n    private void OnInvActionClicked()\n    {\n        HandleActionClick(_invTaskId, ref _invActionMode, ref _invConfirmUntil);\n    }\n\n    private void OnConActionClicked()\n    {\n        HandleActionClick(_conTaskId, ref _conActionMode, ref _conConfirmUntil);\n    }\n\n    private void HandleActionClick(string taskId, ref TaskActionMode mode, ref float confirmUntil)\n    {\n        if (string.IsNullOrEmpty(taskId)) return;\n        if (GameController.I == null) return;\n\n        if (mode == TaskActionMode.Cancel)\n        {\n            GameController.I.CancelOrRetreatTask(taskId);\n            confirmUntil = 0f;\n            Refresh();\n            return;\n        }\n\n        if (mode == TaskActionMode.Retreat)\n        {\n            const float ConfirmWindowSec = 3f;\n            if (Time.unscaledTime <= confirmUntil)\n            {\n                GameController.I.CancelOrRetreatTask(taskId);\n                confirmUntil = 0f;\n                Refresh();\n            }\n            else\n            {\n                confirmUntil = Time.unscaledTime + ConfirmWindowSec;\n                Refresh();\n            }\n        }\n    }\n\n    // ----------------------\n    // Task List UI (scrollable)\n    // ----------------------\n\n    private void CacheTaskListUIIfNeeded()\n    {\n        if (_taskListCached) return;\n\n        // Try a few common roots.\n        Transform scroll = FindDeepChild(transform, \"TaskListScroll\")\n                         ?? FindDeepChild(transform, \"Scroll_Tasks\")\n                         ?? FindDeepChild(transform, \"TaskList\");\n\n        if (scroll != null)\n        {\n            var viewport = scroll.Find(\"Viewport\") ?? FindDeepChild(scroll, \"Viewport\");\n            var content = viewport != null ? (viewport.Find(\"Content\") ?? FindDeepChild(viewport, \"Content\")) : (scroll.Find(\"Content\") ?? FindDeepChild(scroll, \"Content\"));\n\n            if (content != null)\n            {\n                _taskListContent = content;\n\n                // Template search:\n                var tplT = content.Find(\"TaskRowTemplate\");\n                if (tplT == null)\n                {\n                    // Find first inactive child as template.\n                    for (int i = 0; i < content.childCount; i++)\n                    {\n                        var c = content.GetChild(i);\n                        if (c != null && !c.gameObject.activeSelf)\n                        {\n                            tplT = c;\n                            break;\n                        }\n                    }\n                }\n\n                if (tplT != null)\n                {\n                    _taskRowTemplate = tplT.gameObject;\n                    _taskRowTemplate.SetActive(false);\n                }\n            }\n        }\n\n        _taskListCached = true;\n    }\n\n    private bool RefreshTaskListIfPresent(NodeState node)\n    {\n        if (_taskListContent == null || _taskRowTemplate == null) return false;\n\n        // Clear existing instances\n        for (int i = 0; i < _taskRowInstances.Count; i++)\n        {\n            if (_taskRowInstances[i] != null)\n                Destroy(_taskRowInstances[i]);\n        }\n        _taskRowInstances.Clear();\n\n        if (node.Tasks == null || node.Tasks.Count == 0)\n        {\n            // Keep empty; template stays hidden.\n            return true;\n        }\n\n        var tasks = node.Tasks\n            .Where(t => t != null && t.State == TaskState.Active)\n            .OrderBy(t => TaskTypeOrder(t.Type))\n            .ThenByDescending(t => t.CreatedDay)\n            .ThenByDescending(t => t.Progress)\n            .ToList();\n\n        foreach (var t in tasks)\n        {\n            var go = Instantiate(_taskRowTemplate, _taskListContent);\n            go.name = $\"TaskRow_{t.Type}_{t.Id}\";\n            go.SetActive(true);\n            _taskRowInstances.Add(go);\n\n            var row = go.transform;\n            var title = GetTmp(row, \"Title\");\n            var status = GetTmp(row, \"Status\");\n            var people = GetTmp(row, \"People\");\n\n            string taskDefLabel = ResolveTaskDefLabel(t);\n            string titleTextLocal = !string.IsNullOrEmpty(taskDefLabel)\n                ? taskDefLabel\n                : t.Type switch\n                {\n                    TaskType.Investigate => \"调查\",\n                    TaskType.Contain => \"收容\",\n                    TaskType.Manage => \"管理\",\n                    _ => t.Type.ToString()\n                };\n            if (t.Type == TaskType.Contain)\n            {\n                string tn = ResolveContainableName(node, t.TargetContainableId);\n                if (!string.IsNullOrEmpty(tn)) titleTextLocal += $\"：{tn}\";\n            }\n            else if (t.Type == TaskType.Manage)\n            {\n                string an = ResolveManagedAnomalyName(node, t.TargetManagedAnomalyId);\n                if (!string.IsNullOrEmpty(an)) titleTextLocal += $\"：{an}\";\n            }\n            if (title) title.text = titleTextLocal;\n\n            bool hasSquad = t.AssignedAgentIds != null && t.AssignedAgentIds.Count > 0;\n            if (status)\n            {\n                status.text = BuildTaskStatusText(t, hasSquad);\n            }\n\n            if (people)\n            {\n                int c = hasSquad ? t.AssignedAgentIds.Count : 0;\n                people.text = $\"人员：{c}人\";\n            }\n\n            // Action button\n            var btnT = row.Find(\"Btn_Action\");\n            var btn = btnT ? btnT.GetComponent<Button>() : null;\n            var lbl = btnT ? GetTmp(btnT, \"Label\") : null;\n\n            if (btn != null)\n            {\n                btn.onClick.RemoveAllListeners();\n\n                var mode = GetActionMode(t, hasSquad);\n                if (mode == TaskActionMode.None)\n                {\n                    btn.gameObject.SetActive(false);\n                }\n                else\n                {\n                    btn.gameObject.SetActive(true);\n                    if (lbl) lbl.text = BuildActionLabel(mode, t.Id);\n                    string taskId = t.Id;\n\n                    btn.onClick.AddListener(() => OnRowActionClicked(taskId));\n                }\n            }\n        }\n\n        // Layout rebuild (best-effort)\n        var rt = _taskListContent as RectTransform;\n        if (rt != null)\n            LayoutRebuilder.ForceRebuildLayoutImmediate(rt);\n\n        return true;\n    }\n\n    private void OnRowActionClicked(string taskId)\n    {\n        if (string.IsNullOrEmpty(taskId) || GameController.I == null) return;\n\n        if (!GameController.I.TryGetTask(taskId, out var node, out var task) || task == null) return;\n        if (task.State != TaskState.Active) return;\n\n        bool hasSquad = task.AssignedAgentIds != null && task.AssignedAgentIds.Count > 0;\n        var mode = GetActionMode(task, hasSquad);\n\n        if (mode == TaskActionMode.Cancel)\n        {\n            GameController.I.CancelOrRetreatTask(taskId);\n            _rowConfirmUntil.Remove(taskId);\n            Refresh();\n            return;\n        }\n\n        if (mode == TaskActionMode.Retreat)\n        {\n            const float ConfirmWindowSec = 3f;\n            float until = 0f;\n            _rowConfirmUntil.TryGetValue(taskId, out until);\n\n            if (Time.unscaledTime <= until)\n            {\n                GameController.I.CancelOrRetreatTask(taskId);\n                _rowConfirmUntil.Remove(taskId);\n                Refresh();\n            }\n            else\n            {\n                _rowConfirmUntil[taskId] = Time.unscaledTime + ConfirmWindowSec;\n                Refresh();\n            }\n        }\n    }\n\n    private static int TaskStateOrder(TaskState s)\n    {\n        // Active first, then Completed, then Cancelled\n        return s switch\n        {\n            TaskState.Active => 0,\n            TaskState.Completed => 1,\n            TaskState.Cancelled => 2,\n            _ => 9\n        };\n    }\n\n    private static int TaskTypeOrder(TaskType t)\n    {\n        // Investigate first, then Contain, then Manage\n        return t switch\n        {\n            TaskType.Investigate => 0,\n            TaskType.Contain => 1,\n            TaskType.Manage => 2,\n            _ => 9\n        };\n    }\n\n    private static int GetContainableCount(NodeState node)\n    {\n        if (node?.KnownAnomalyDefIds == null || node.KnownAnomalyDefIds.Count == 0) return 0;\n\n        HashSet<string> contained = null;\n        if (node.ManagedAnomalies != null && node.ManagedAnomalies.Count > 0)\n        {\n            contained = new HashSet<string>(node.ManagedAnomalies\n                .Where(m => m != null && !string.IsNullOrEmpty(m.AnomalyId))\n                .Select(m => m.AnomalyId));\n        }\n\n        int count = 0;\n        foreach (var defId in node.KnownAnomalyDefIds)\n        {\n            if (string.IsNullOrEmpty(defId)) continue;\n            if (contained != null && contained.Contains(defId)) continue;\n            count += 1;\n        }\n        return count;\n    }\n\n    private static string ResolveContainableName(NodeState node, string containableId)\n    {\n        if (node == null || node.KnownAnomalyDefIds == null || node.KnownAnomalyDefIds.Count == 0) return \"\";\n        var registry = DataRegistry.Instance;\n        string defId = containableId;\n        if (string.IsNullOrEmpty(defId))\n            defId = node.KnownAnomalyDefIds[0];\n        if (string.IsNullOrEmpty(defId)) return \"\";\n        if (registry.AnomaliesById.TryGetValue(defId, out var def) && def != null)\n            return def.name;\n        return defId;\n    }\n\n    private static string ResolveManagedAnomalyName(NodeState node, string managedAnomalyId)\n    {\n        if (node == null || node.ManagedAnomalies == null || node.ManagedAnomalies.Count == 0) return \"\";\n        if (!string.IsNullOrEmpty(managedAnomalyId))\n        {\n            var m = node.ManagedAnomalies.FirstOrDefault(x => x != null && x.Id == managedAnomalyId);\n            if (m != null) return m.Name ?? \"\";\n        }\n        return \"\";\n    }\n\n    private static string ResolveTaskDefLabel(NodeTask task)\n    {\n        if (task == null) return \"\";\n        var def = DataRegistry.Instance != null ? DataRegistry.Instance.GetTaskDefById(task.TaskDefId) : null;\n        if (def != null && !string.IsNullOrEmpty(def.name)) return def.name;\n        return task.TaskDefId ?? \"\";\n    }\n\n    private static string BuildTaskStatusText(NodeTask t, bool hasSquad)\n    {\n        if (t.State == TaskState.Completed) return \"状态：已完成\";\n        if (t.State == TaskState.Cancelled) return \"状态：已取消\";\n\n        if (!hasSquad) return \"状态：未指派\";\n\n        // Manage tasks: no \"待开始\" concept; once assigned, it is immediately \"管理中\".\n        if (t.Type == TaskType.Manage)\n            return \"状态：管理中\";\n\n        if (t.Progress <= EPS) return \"状态：待开始\";\n\n        return $\"状态：进行中（{(int)(GetTaskProgress01(t) * 100)}%）\";\n    }\n\n    private static TaskActionMode GetActionMode(NodeTask t, bool hasSquad)\n    {\n        if (t == null) return TaskActionMode.None;\n        if (t.State != TaskState.Active) return TaskActionMode.None;\n        if (!hasSquad) return TaskActionMode.None;\n        // Manage tasks: always allow Cancel to release agents; no Retreat confirmation flow.\n        if (t.Type == TaskType.Manage) return TaskActionMode.Cancel;\n\n        return (t.Progress > EPS) ? TaskActionMode.Retreat : TaskActionMode.Cancel;\n    }\n\n    private static float GetTaskProgress01(NodeTask task)\n    {\n        if (task == null) return 0f;\n        if (task.Type == TaskType.Manage) return 0f;\n        int baseDays = Mathf.Max(1, DataRegistry.Instance.GetTaskBaseDaysWithWarn(task.Type, 1));\n        return Mathf.Clamp01(task.Progress / baseDays);\n    }\n\n    private string BuildActionLabel(TaskActionMode mode, string taskId)\n    {\n        if (mode == TaskActionMode.Cancel) return \"取消\";\n        if (mode == TaskActionMode.Retreat)\n        {\n            float until = 0f;\n            _rowConfirmUntil.TryGetValue(taskId, out until);\n            return (Time.unscaledTime <= until) ? \"确认撤退\" : \"撤退\";\n        }\n        return \"\";\n    }\n\n    // ----------------------\n    // Dispatch buttons\n    // ----------------------\n\n    private void UpdateDispatchButtons(NodeState n, int containableCount, bool hasContainables)\n    {\n        if (n == null) return;\n\n        // N-task model:\n        // - Investigate: can be initiated freely.\n        // - Contain: requires discovered containables.\n\n        bool canInvestigate = true; // 调查随时可发起\n        bool canContain = n.Status != NodeStatus.Secured && hasContainables; // 收容必须有可收容物\n\n        _containDisabledForNoAnomalies = !hasContainables && n.Status != NodeStatus.Secured;\n\n\n        if (investigateButton) investigateButton.interactable = canInvestigate;\n        if (containButton) containButton.interactable = canContain && hasContainables;\n\n        Debug.Log($\"[NodePanelContainGate] nodeId={_nodeId} containableCount={containableCount} hasContainables={hasContainables} canContain={canContain} btn={(containButton ? containButton.interactable : false)}\");\n    }\n\n    private void UpdateManageButton(NodeState n)\n    {\n        if (!manageButton) return;\n        if (n == null)\n        {\n            manageButton.interactable = false;\n            return;\n        }\n\n        // 管理入口属于“节点内异常”，因此按当前节点是否存在已收容异常来决定是否可点。\n        // 如需允许空态也可打开，把下面的 hasAny 判断改为 true。\n        bool hasAny = n.ManagedAnomalies != null && n.ManagedAnomalies.Any(x => x != null && x.Favorited);\n        manageButton.interactable = hasAny;\n    }\n\n    // ----------------------\n    // Utilities\n    // ----------------------\n\n    private static TMP_Text GetTmp(Transform parent, string childName)\n    {\n        if (parent == null) return null;\n        // Deep search to support templates like TaskRowTemplate/Col/Title\n        var t = FindDeepChild(parent, childName);\n        if (t == null) return null;\n        return t.GetComponent<TMP_Text>();\n    }\n\n    private static Transform FindDeepChild(Transform root, string name)\n    {\n        if (root == null) return null;\n        if (root.name == name) return root;\n\n        for (int i = 0; i < root.childCount; i++)\n        {\n            var c = root.GetChild(i);\n            var r = FindDeepChild(c, name);\n            if (r != null) return r;\n        }\n        return null;\n    }\n}\n// </EXPORT_BLOCK>"
        },
        {
            "id": 3,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class ConfirmDialog : MonoBehaviour\n{\n    [Header(\"Wiring\")]\n    [SerializeField] private Button backgroundButton;   // 点背景=取消（可选）\n    [SerializeField] private TMP_Text titleText;\n    [SerializeField] private TMP_Text messageText;\n\n    [SerializeField] private Button confirmButton;\n    [SerializeField] private TMP_Text confirmLabel;\n\n    [SerializeField] private Button cancelButton;\n    [SerializeField] private TMP_Text cancelLabel;\n\n    private Action _onConfirm;\n    private Action _onCancel;\n\n    public event Action OnClosed;\n\n    private void Awake()\n    {\n        // 防止重复绑定（Domain Reload / 重新进 Play）\n        if (backgroundButton)\n        {\n            backgroundButton.onClick.RemoveAllListeners();\n            backgroundButton.onClick.AddListener(Cancel);\n        }\n\n        if (confirmButton)\n        {\n            confirmButton.onClick.RemoveAllListeners();\n            confirmButton.onClick.AddListener(Confirm);\n        }\n\n        if (cancelButton)\n        {\n            cancelButton.onClick.RemoveAllListeners();\n            cancelButton.onClick.AddListener(Cancel);\n        }\n\n        gameObject.SetActive(false);\n    }\n\n    public void ShowConfirm(\n        string title,\n        string message,\n        Action onConfirm,\n        Action onCancel = null,\n        string confirmText = \"确认\",\n        string cancelText = \"取消\")\n    {\n        _onConfirm = onConfirm;\n        _onCancel = onCancel;\n\n        if (titleText) titleText.text = title ?? \"\";\n        if (messageText) messageText.text = message ?? \"\";\n\n        if (confirmLabel) confirmLabel.text = string.IsNullOrEmpty(confirmText) ? \"确认\" : confirmText;\n        if (cancelLabel) cancelLabel.text = string.IsNullOrEmpty(cancelText) ? \"取消\" : cancelText;\n\n        if (cancelButton) cancelButton.gameObject.SetActive(true);\n\n        gameObject.SetActive(true);\n    }\n\n    public void ShowInfo(string title, string message, string okText = \"知道了\")\n    {\n        _onConfirm = null;\n        _onCancel = null;\n\n        if (titleText) titleText.text = title ?? \"\";\n        if (messageText) messageText.text = message ?? \"\";\n\n        if (confirmLabel) confirmLabel.text = string.IsNullOrEmpty(okText) ? \"知道了\" : okText;\n        if (cancelButton) cancelButton.gameObject.SetActive(false);\n\n        gameObject.SetActive(true);\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n        _onConfirm = null;\n        _onCancel = null;\n        OnClosed?.Invoke();\n    }\n\n    private void Confirm()\n    {\n        var cb = _onConfirm;\n        Hide();\n        cb?.Invoke();\n    }\n\n    private void Cancel()\n    {\n        var cb = _onCancel;\n        Hide();\n        cb?.Invoke();\n    }\n}\n\n// <CONFIRM_DIALOG_PREFAB_BUILDER>\n// <CONFIRM_DIALOG_PREFAB_BUILDER>\n#if UNITY_EDITOR\n// Auto-generated helper: create/update ConfirmDialog.prefab via Unity menu.\n// Usage: Tools > SCP Manager > Create ConfirmDialog Prefab\npublic static class ConfirmDialogPrefabBuilder\n{\n    [UnityEditor.MenuItem(\"Tools/SCP Manager/Create ConfirmDialog Prefab\")]\n    public static void CreateOrUpdate()\n    {\n        const string prefabPath = \"Assets/Prefabs/ConfirmDialog.prefab\";\n        var dir = System.IO.Path.GetDirectoryName(prefabPath);\n        if (!string.IsNullOrEmpty(dir) && !System.IO.Directory.Exists(dir)) System.IO.Directory.CreateDirectory(dir);\n\n        var root = new UnityEngine.GameObject(\"ConfirmDialog\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(UnityEngine.UI.Image),\n            typeof(UnityEngine.CanvasGroup),\n            typeof(ConfirmDialog));\n\n        var rootRT = root.GetComponent<UnityEngine.RectTransform>();\n        rootRT.anchorMin = new UnityEngine.Vector2(0.5f, 0.5f);\n        rootRT.anchorMax = new UnityEngine.Vector2(0.5f, 0.5f);\n        rootRT.pivot = new UnityEngine.Vector2(0.5f, 0.5f);\n        rootRT.sizeDelta = new UnityEngine.Vector2(900f, 560f);\n        rootRT.anchoredPosition = UnityEngine.Vector2.zero;\n\n        var rootImg = root.GetComponent<UnityEngine.UI.Image>();\n        rootImg.color = new UnityEngine.Color(0f, 0f, 0f, 0.65f);\n        rootImg.raycastTarget = true;\n\n        var cg = root.GetComponent<UnityEngine.CanvasGroup>();\n        cg.alpha = 1f;\n        cg.blocksRaycasts = true;\n        cg.interactable = true;\n\n        // Panel\n        var panel = new UnityEngine.GameObject(\"Panel\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(UnityEngine.UI.Image));\n        panel.transform.SetParent(root.transform, false);\n\n        var panelRT = panel.GetComponent<UnityEngine.RectTransform>();\n        panelRT.anchorMin = new UnityEngine.Vector2(0.5f, 0.5f);\n        panelRT.anchorMax = new UnityEngine.Vector2(0.5f, 0.5f);\n        panelRT.pivot = new UnityEngine.Vector2(0.5f, 0.5f);\n        panelRT.sizeDelta = new UnityEngine.Vector2(820f, 460f);\n        panelRT.anchoredPosition = UnityEngine.Vector2.zero;\n\n        var panelImg = panel.GetComponent<UnityEngine.UI.Image>();\n        panelImg.color = new UnityEngine.Color(0.10f, 0.10f, 0.10f, 0.95f);\n        panelImg.raycastTarget = true;\n\n        // Title\n        var titleGO = new UnityEngine.GameObject(\"Title\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(TMPro.TextMeshProUGUI));\n        titleGO.transform.SetParent(panel.transform, false);\n\n        var titleRT = titleGO.GetComponent<UnityEngine.RectTransform>();\n        titleRT.anchorMin = new UnityEngine.Vector2(0f, 1f);\n        titleRT.anchorMax = new UnityEngine.Vector2(1f, 1f);\n        titleRT.pivot = new UnityEngine.Vector2(0.5f, 1f);\n        titleRT.sizeDelta = new UnityEngine.Vector2(0f, 80f);\n        titleRT.anchoredPosition = new UnityEngine.Vector2(0f, -20f);\n\n        var titleText = titleGO.GetComponent<TMPro.TextMeshProUGUI>();\n        titleText.text = \"Confirm\";\n        titleText.fontSize = 48;\n        titleText.alignment = TMPro.TextAlignmentOptions.Center;\n\n        // Message\n        var msgGO = new UnityEngine.GameObject(\"Message\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(TMPro.TextMeshProUGUI));\n        msgGO.transform.SetParent(panel.transform, false);\n\n        var msgRT = msgGO.GetComponent<UnityEngine.RectTransform>();\n        msgRT.anchorMin = new UnityEngine.Vector2(0f, 0.25f);\n        msgRT.anchorMax = new UnityEngine.Vector2(1f, 0.85f);\n        msgRT.pivot = new UnityEngine.Vector2(0.5f, 0.5f);\n        msgRT.offsetMin = new UnityEngine.Vector2(30f, 0f);\n        msgRT.offsetMax = new UnityEngine.Vector2(-30f, 0f);\n\n        var msgText = msgGO.GetComponent<TMPro.TextMeshProUGUI>();\n        msgText.text = \"Are you sure?\";\n        msgText.fontSize = 32;\n        msgText.alignment = TMPro.TextAlignmentOptions.TopLeft;\n        msgText.textWrappingMode = TMPro.TextWrappingModes.Normal;\n\n        // Buttons row\n        var btnRow = new UnityEngine.GameObject(\"Buttons\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.UI.HorizontalLayoutGroup));\n        btnRow.transform.SetParent(panel.transform, false);\n\n        var btnRowRT = btnRow.GetComponent<UnityEngine.RectTransform>();\n        btnRowRT.anchorMin = new UnityEngine.Vector2(0f, 0f);\n        btnRowRT.anchorMax = new UnityEngine.Vector2(1f, 0f);\n        btnRowRT.pivot = new UnityEngine.Vector2(0.5f, 0f);\n        btnRowRT.sizeDelta = new UnityEngine.Vector2(0f, 110f);\n        btnRowRT.anchoredPosition = new UnityEngine.Vector2(0f, 20f);\n\n        var hlg = btnRow.GetComponent<UnityEngine.UI.HorizontalLayoutGroup>();\n        hlg.padding = new UnityEngine.RectOffset(30, 30, 10, 10);\n        hlg.spacing = 20f;\n        hlg.childForceExpandHeight = true;\n        hlg.childForceExpandWidth = true;\n\n        var okBtn = CreateButton(btnRow.transform, \"ConfirmButton\", \"Confirm\");\n        var cancelBtn = CreateButton(btnRow.transform, \"CancelButton\", \"Cancel\");\n\n        // Auto-wire fields on ConfirmDialog (reflection; name is fuzzy-safe)\n        var dlg = root.GetComponent<ConfirmDialog>();\n        AutoWireConfirmDialog(dlg, titleText, msgText, okBtn, cancelBtn);\n\n        var prefab = UnityEditor.PrefabUtility.SaveAsPrefabAsset(root, prefabPath);\n        UnityEngine.Object.DestroyImmediate(root);\n        UnityEditor.AssetDatabase.SaveAssets();\n        UnityEditor.AssetDatabase.Refresh();\n        UnityEditor.Selection.activeObject = prefab;\n        UnityEditor.EditorGUIUtility.PingObject(prefab);\n        UnityEngine.Debug.Log($\"[ConfirmDialogPrefabBuilder] Created/Updated: {prefabPath}\");\n    }\n\n    static UnityEngine.UI.Button CreateButton(UnityEngine.Transform parent, string name, string label)\n    {\n        var go = new UnityEngine.GameObject(name,\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(UnityEngine.UI.Image),\n            typeof(UnityEngine.UI.Button),\n            typeof(UnityEngine.UI.LayoutElement));\n        go.transform.SetParent(parent, false);\n\n        var le = go.GetComponent<UnityEngine.UI.LayoutElement>();\n        le.preferredHeight = 90f;\n\n        var img = go.GetComponent<UnityEngine.UI.Image>();\n        img.color = new UnityEngine.Color(1f, 1f, 1f, 0.10f);\n\n        var textGO = new UnityEngine.GameObject(\"Text\",\n            typeof(UnityEngine.RectTransform),\n            typeof(UnityEngine.CanvasRenderer),\n            typeof(TMPro.TextMeshProUGUI));\n        textGO.transform.SetParent(go.transform, false);\n\n        var rt = textGO.GetComponent<UnityEngine.RectTransform>();\n        rt.anchorMin = UnityEngine.Vector2.zero;\n        rt.anchorMax = UnityEngine.Vector2.one;\n        rt.sizeDelta = UnityEngine.Vector2.zero;\n\n        var t = textGO.GetComponent<TMPro.TextMeshProUGUI>();\n        t.text = label;\n        t.fontSize = 34;\n        t.alignment = TMPro.TextAlignmentOptions.Center;\n\n        return go.GetComponent<UnityEngine.UI.Button>();\n    }\n\n    static void AutoWireConfirmDialog(ConfirmDialog dlg, TMPro.TextMeshProUGUI title, TMPro.TextMeshProUGUI msg, UnityEngine.UI.Button ok, UnityEngine.UI.Button cancel)\n    {\n        if (dlg == null) return;\n        var t = dlg.GetType();\n        var flags = System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic;\n\n        foreach (var f in t.GetFields(flags))\n        {\n            if (f.FieldType == typeof(TMPro.TextMeshProUGUI))\n            {\n                var n = f.Name.ToLowerInvariant();\n                if (n.Contains(\"title\") && title != null) f.SetValue(dlg, title);\n                else if ((n.Contains(\"msg\") || n.Contains(\"message\") || n.Contains(\"desc\") || n.Contains(\"content\")) && msg != null) f.SetValue(dlg, msg);\n            }\n            else if (f.FieldType == typeof(UnityEngine.UI.Button))\n            {\n                var n = f.Name.ToLowerInvariant();\n                if ((n.Contains(\"ok\") || n.Contains(\"yes\") || n.Contains(\"confirm\") || n.Contains(\"accept\")) && ok != null) f.SetValue(dlg, ok);\n                else if ((n.Contains(\"no\") || n.Contains(\"cancel\") || n.Contains(\"close\") || n.Contains(\"reject\")) && cancel != null) f.SetValue(dlg, cancel);\n            }\n        }\n\n        UnityEditor.EditorUtility.SetDirty(dlg);\n    }\n}\n#endif\n// </CONFIRM_DIALOG_PREFAB_BUILDER>\n// </CONFIRM_DIALOG_PREFAB_BUILDER>"
        },
        {
            "id": 10,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\nusing System.Collections.Generic;\nusing Core;\nusing Data;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class RecruitPanel : MonoBehaviour\n{\n    [Header(\"Texts\")]\n    [SerializeField] private TMP_Text titleText;\n    [SerializeField] private TMP_Text moneyText;\n    [SerializeField] private TMP_Text costText;\n    [SerializeField] private TMP_Text statusText;\n\n    [Header(\"Buttons\")]\n    [SerializeField] private Button confirmButton;\n    [SerializeField] private TMP_Text confirmLabel;\n    [SerializeField] private Button cancelButton;\n    [SerializeField] private TMP_Text cancelLabel;\n\n    [Header(\"Agent List\")]\n    [SerializeField] private RectTransform agentListContent;\n    [SerializeField] private ScrollRect agentListScrollRect;\n    [SerializeField] private AgentPickerItemView itemPrefab;\n\n    private readonly List<GameObject> _agentItems = new();\n    private RecruitCandidate _candidate;\n\n    private void Awake()\n    {\n        BindButtons();\n        if (!ValidateBindings()) return;\n        gameObject.SetActive(false);\n    }\n\n    private void OnEnable()\n    {\n        if (!ValidateBindings()) return;\n    }\n\n    public void Show()\n    {\n        if (!ValidateBindings()) return;\n        Refresh();\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n    }\n\n    public void Refresh()\n    {\n        if (!ValidateBindings()) return;\n        if (GameController.I == null) return;\n\n        if (_candidate == null)\n        {\n            _candidate = GameController.I.GenerateRecruitCandidate();\n        }\n\n        int hireCost = _candidate?.cost ?? GetHireCost();\n        int candidateLevel = _candidate?.agent?.Level ?? 1;\n\n        int money = GameController.I.State?.Money ?? 0;\n        bool canAfford = money >= hireCost;\n\n        if (titleText) titleText.text = \"Personnel Management\";\n        if (moneyText) moneyText.text = $\"Money: {money}\";\n        if (costText) costText.text = $\"雇佣费用：{hireCost}（Lv{candidateLevel}）\";\n        if (statusText) statusText.text = canAfford ? \"Ready\" : \"资金不足\";\n\n        if (confirmButton) confirmButton.interactable = canAfford;\n        if (confirmLabel) confirmLabel.text = \"Hire\";\n        if (cancelLabel) cancelLabel.text = \"Close\";\n\n        // Rebuild agent list to show current status\n        EnsureListLayout();\n        RebuildAgentList();\n        EnsureListLayout();\n    }\n\n    private void BindButtons()\n    {\n        if (confirmButton)\n        {\n            confirmButton.onClick.RemoveAllListeners();\n            confirmButton.onClick.AddListener(OnConfirm);\n        }\n\n        if (cancelButton)\n        {\n            cancelButton.onClick.RemoveAllListeners();\n            cancelButton.onClick.AddListener(Hide);\n        }\n    }\n\n    private int GetHireCost()\n    {\n        return DataRegistry.Instance.GetBalanceIntWithWarn(\"HireCost\", 100);\n    }\n\n    private void RebuildAgentList()\n    {\n        if (!ValidateBindings()) return;\n        EnsureListLayout();\n        // Clear existing items (only children, keep content)\n        _agentItems.Clear();\n        foreach (Transform child in agentListContent)\n        {\n            if (child) Destroy(child.gameObject);\n        }\n\n        if (agentListContent == null || itemPrefab == null)\n        {\n            // Agent list not set up yet\n            return;\n        }\n\n        var gc = GameController.I;\n        if (gc == null || gc.State?.Agents == null) return;\n\n        // Create an item for each agent\n        foreach (var agent in gc.State.Agents)\n        {\n            if (agent == null) continue;\n\n            // Get busy status using BuildAgentBusyText\n            string busyText = Sim.BuildAgentBusyText(gc.State, agent.Id);\n            bool isBusy = !string.IsNullOrEmpty(busyText);\n            string statusText = isBusy\n                ? $\"<color=#FF6666>{busyText}</color>\"\n                : \"<color=#66FF66>IDLE</color>\";\n\n            // Create agent item UI from prefab\n            var item = Instantiate(itemPrefab, agentListContent, false);\n            item.name = $\"AgentItem_{agent.Id}\";\n            string displayName = BuildAgentDisplayName(agent);\n            item.Bind(agent, displayName, BuildAgentAttrLine(agent), isBusy, false, null, statusText);\n            var itemGo = item.gameObject;\n            var le = itemGo.GetComponent<LayoutElement>() ?? itemGo.AddComponent<LayoutElement>();\n            le.minHeight = 70f;\n            le.preferredHeight = 70f;\n            le.flexibleHeight = 0f;\n\n            var rt = itemGo.GetComponent<RectTransform>();\n            if (rt)\n            {\n                rt.anchorMin = new Vector2(0f, 1f);\n                rt.anchorMax = new Vector2(1f, 1f);\n                rt.pivot = new Vector2(0.5f, 1f);\n                rt.anchoredPosition = Vector2.zero;\n                rt.sizeDelta = Vector2.zero;\n            }\n            _agentItems.Add(item.gameObject);\n        }\n\n        LayoutRebuilder.ForceRebuildLayoutImmediate(agentListContent);\n        Canvas.ForceUpdateCanvases();\n    }\n\n    private static string BuildAgentAttrLine(AgentState a)\n    {\n        if (a == null) return \"\";\n        return $\"P{a.Perception} O{a.Operation} R{a.Resistance} Pow{a.Power}\";\n    }\n\n    private static string BuildAgentDisplayName(AgentState a)\n    {\n        if (a == null) return string.Empty;\n        return string.IsNullOrEmpty(a.Name) ? a.Id : a.Name;\n    }\n\n    private void OnConfirm()\n    {\n        if (GameController.I == null) return;\n\n        if (_candidate == null)\n        {\n            _candidate = GameController.I.GenerateRecruitCandidate();\n        }\n\n        if (!GameController.I.TryHireAgent(_candidate, out var agent))\n        {\n            if (statusText) statusText.text = \"资金不足\";\n            Refresh();\n            return;\n        }\n\n        if (statusText) statusText.text = $\"已招募 {agent.Name}\";\n        _candidate = GameController.I.GenerateRecruitCandidate();\n        Refresh();\n        Canvas.ForceUpdateCanvases();\n        if (agentListScrollRect) agentListScrollRect.verticalNormalizedPosition = 0f;\n    }\n\n    private void EnsureRuntimeUI()\n    {\n        if (titleText && moneyText && costText && confirmButton && cancelButton) return;\n        Debug.LogError(\"RecruitPanel: UI references missing. Assign via Inspector; runtime UI creation is disabled.\");\n    }\n\n    private bool ValidateBindings()\n    {\n        if (!agentListContent || !agentListScrollRect || !itemPrefab)\n        {\n            Debug.LogError(\"RecruitPanel: agentListContent/agentListScrollRect/itemPrefab not assigned in Inspector.\");\n            return false;\n        }\n\n        return true;\n    }\n\n    private void EnsureListLayout()\n    {\n        if (!agentListContent || !agentListScrollRect) return;\n\n        var vlg = agentListContent.GetComponent<VerticalLayoutGroup>() ?? agentListContent.gameObject.AddComponent<VerticalLayoutGroup>();\n        vlg.childControlHeight = true;\n        vlg.childControlWidth = true;\n        vlg.childForceExpandHeight = false;\n        vlg.childForceExpandWidth = true;\n        vlg.spacing = 8f;\n        vlg.padding = new RectOffset(0, 0, 0, 0);\n\n        var csf = agentListContent.GetComponent<ContentSizeFitter>() ?? agentListContent.gameObject.AddComponent<ContentSizeFitter>();\n        csf.verticalFit = ContentSizeFitter.FitMode.PreferredSize;\n\n        if (agentListScrollRect.content == null)\n        {\n            agentListScrollRect.content = agentListContent;\n        }\n    }\n\n}"
        },
        {
            "id": 11,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "Prefab loaded."
        },
        {
            "id": 12,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        },
        {
            "id": 20,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Assets/Scripts/UI/AnomalyManagePanel.cs\n// Purpose: Management panel for contained anomalies (NODE-SCOPED).\n// - Left: favorited managed anomalies of a specific node (NodeState.ManagedAnomalies)\n// - Right: agent list (reuses AgentPickerItemView) to assign managers\n// - Confirm creates/updates a NodeTask (TaskType.Manage) and assigns agents via NodeTask.AssignedAgentIds.\n//   Sim awards daily NegEntropy based on active Manage tasks.\n//\n// Data scope note:\n// - Containables & post-containment management belong to the node that contained them.\n// - Global currency NegEntropy is accumulated in GameState, but per-anomaly state is stored under NodeState.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Core;\nusing Data;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class AnomalyManagePanel : MonoBehaviour\n{\n    public class TargetEntry\n    {\n        public string id;\n        public string title;\n        public string subtitle;\n        public bool disabled;\n    }\n\n    private enum AssignPanelMode\n    {\n        Manage,\n        Generic\n    }\n\n    [Header(\"Left: Anomaly list\")]\n    [SerializeField] private Transform anomalyListContent;\n    [SerializeField] private GameObject anomalyListItemPrefab; // must have Button + TMP_Text named \"Label\" (or any TMP_Text)\n\n    [Header(\"Right: Agent list (AgentPickerItemView)\")]\n    [SerializeField] private Transform agentListContent;\n    [SerializeField] private GameObject agentPickerItemPrefab; // prefab with AgentPickerItemView\n\n    [Header(\"Actions\")]\n    [SerializeField] private Button confirmButton;\n    [SerializeField] private Button closeButton;\n    [SerializeField] private TMP_Text headerText; // optional\n    [SerializeField] private TMP_Text hintText;   // optional\n\n    private readonly List<GameObject> _anomalyItems = new();\n    private readonly List<AgentPickerItemView> _agentItems = new();\n    private readonly List<TargetEntry> _currentTargets = new();\n\n    private string _selectedTargetId;\n    private string _nodeId; // management context node id (set by UIPanelRoot.ManageNodeId)\n    private readonly HashSet<string> _selectedAgentIds = new();\n    private int _slotsMin = 1;\n    private int _slotsMax = int.MaxValue;\n    private AssignPanelMode _mode = AssignPanelMode.Manage;\n    private Action<string, List<string>> _onConfirm;\n\n    void Awake()\n    {\n        if (closeButton)\n        {\n            closeButton.onClick.RemoveAllListeners();\n            closeButton.onClick.AddListener(Hide);\n        }\n\n        if (confirmButton)\n        {\n            confirmButton.onClick.RemoveAllListeners();\n            confirmButton.onClick.AddListener(Confirm);\n        }\n    }\n\n    void OnEnable()\n    {\n        var root = UIPanelRoot.I;\n        _nodeId = root != null ? root.ManageNodeId : null;\n        // IMPORTANT: do not auto RefreshUI here.\n        // This panel is reused for Investigate/Contain assignment and auto-refresh would rebuild Manage mode & spam logs.\n        // Only RefreshUI will be called by explicit Show() calls.\n    }\n\n    public void Show()\n    {\n        ClearSelectionState();\n        _mode = AssignPanelMode.Manage;\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n        RefreshUI();\n    }\n\n    // Optional explicit node binding (recommended if you call panel directly)\n    public void Show(string nodeId)\n    {\n        ClearSelectionState();\n        ShowForNode(nodeId);\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n        GameControllerTaskExt.LogBusySnapshot(GameController.I, \"AnomalyManagePanel.Hide\");\n    }\n\n    public void ShowForNode(string nodeId)\n    {\n        ClearSelectionState();\n        _mode = AssignPanelMode.Manage;\n        _nodeId = nodeId;\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n        RefreshUI();\n    }\n\n    // --------------------\n    // Refresh\n    // --------------------\n\n    public void RefreshUI()\n    {\n        // Only refresh in Manage mode; other modes use ShowGenericInternal\n        if (_mode != AssignPanelMode.Manage) return;\n\n        var gc = GameController.I;\n        if (gc == null) return;\n        var registry = DataRegistry.Instance;\n        (_slotsMin, _slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Manage, 1, int.MaxValue);\n\n        var node = !string.IsNullOrEmpty(_nodeId) ? gc.GetNode(_nodeId) : null;\n        var list = GetFavoritedAnomalies(node);\n\n        // Keep selection valid\n        if (string.IsNullOrEmpty(_selectedTargetId) || !list.Any(x => x.Id == _selectedTargetId))\n            _selectedTargetId = list.FirstOrDefault()?.Id;\n        if (list.Count == 0)\n        {\n            _selectedTargetId = null;\n            _selectedAgentIds.Clear();\n        }\n\n        var targets = list\n            .Select(a => new TargetEntry\n            {\n                id = a.Id,\n                title = BuildAnomalyLabel(a, GetCurrentManagerCount(node, a.Id)),\n                subtitle = null,\n                disabled = false\n            })\n            .ToList();\n\n        string hint = \"\";\n        if (list.Count == 0)\n        {\n            if (string.IsNullOrEmpty(_nodeId)) hint = \"管理面板缺少节点上下文（ManageNodeId 为空）。\";\n            else hint = \"该节点暂无已收容异常。请先完成收容。\";\n        }\n        else\n        {\n            hint = \"选择异常，然后分配干员开始管理（每日产出负熵）。\";\n        }\n\n        ShowGenericInternal(\"管理：选择异常\", hint, targets, _slotsMin, _slotsMax, HandleManageConfirm, \"Manage\");\n        UpdateHeader();\n    }\n\n    private static List<ManagedAnomalyState> GetFavoritedAnomalies(NodeState node)\n    {\n        if (node?.ManagedAnomalies == null) return new List<ManagedAnomalyState>();\n        return node.ManagedAnomalies\n            .Where(x => x != null && x.Favorited)\n            .OrderByDescending(x => x.Level)\n            .ThenBy(x => x.Name)\n            .ToList();\n    }\n\n    public void ShowGeneric(\n        string header,\n        string hint,\n        List<TargetEntry> targets,\n        int agentSlotsMin,\n        int agentSlotsMax,\n        Action<string, List<string>> onConfirm,\n        string modeLabel = \"Generic\")\n    {\n        ShowGenericInternal(header, hint, targets, agentSlotsMin, agentSlotsMax, onConfirm, modeLabel);\n    }\n\n    private void ShowGenericInternal(\n        string header,\n        string hint,\n        List<TargetEntry> targets,\n        int agentSlotsMin,\n        int agentSlotsMax,\n        Action<string, List<string>> onConfirm,\n        string modeLabel)\n    {\n        ClearSelectionState();\n        _mode = modeLabel == \"Manage\" ? AssignPanelMode.Manage : AssignPanelMode.Generic;\n        _onConfirm = onConfirm;\n        _slotsMin = agentSlotsMin;\n        _slotsMax = agentSlotsMax;\n\n        if (headerText) headerText.text = header ?? \"\";\n        if (hintText) hintText.text = hint ?? \"\";\n\n        var safeTargets = targets ?? new List<TargetEntry>();\n        if (string.IsNullOrEmpty(_selectedTargetId) || !safeTargets.Any(x => x != null && x.id == _selectedTargetId))\n            _selectedTargetId = safeTargets.FirstOrDefault()?.id;\n\n        RebuildTargetList(safeTargets);\n        RebuildAgentList();\n        RefreshConfirmState();\n\n        // Disable confirm if no targets available (targets=0 must disable Confirm)\n        if (confirmButton)\n        {\n            confirmButton.interactable = (safeTargets.Count > 0) && confirmButton.interactable;\n        }\n\n        // Log assignment panel state (Investigate/Contain should not trigger this repeatedly)\n        Debug.Log($\"[AssignPanel] mode={modeLabel} targets={safeTargets.Count} slots={_slotsMin}-{_slotsMax}\");\n    }\n\n    private void RebuildTargetList(List<TargetEntry> list)\n    {\n        // Clear\n        for (int i = 0; i < _anomalyItems.Count; i++)\n            if (_anomalyItems[i]) Destroy(_anomalyItems[i]);\n        _anomalyItems.Clear();\n        _currentTargets.Clear();\n\n        if (!anomalyListContent || !anomalyListItemPrefab)\n            return;\n\n        if (list == null || list.Count == 0) return;\n\n        foreach (var entry in list)\n        {\n            var go = Instantiate(anomalyListItemPrefab, anomalyListContent);\n            string entryId = entry?.id ?? \"\";\n            go.name = \"Target_\" + entryId;\n            _anomalyItems.Add(go);\n            _currentTargets.Add(entry);\n\n            SetListItemLabels(go, entry);\n\n            bool selected = (entryId == _selectedTargetId);\n            SetListItemSelectedVisual(go, selected);\n\n            var btn = go.GetComponentInChildren<Button>(true);\n            if (btn)\n            {\n                btn.onClick.RemoveAllListeners();\n                string id = entryId;\n                btn.interactable = entry == null || !entry.disabled;\n                btn.onClick.AddListener(() => SelectTarget(id));\n            }\n        }\n    }\n\n    private static string BuildAnomalyLabel(ManagedAnomalyState a, int mgr)\n    {\n        if (a == null) return \"\";\n        return $\"Lv{a.Level} {a.Name}  (管理:{mgr})\";\n    }\n\n    private void SetListItemSelectedVisual(GameObject go, bool selected)\n    {\n        // Minimal visual: try Image tint if present.\n        var img = go.GetComponentInChildren<Image>(true);\n        if (img)\n        {\n            img.color = selected ? new Color(0f, 0.68f, 0.71f, 0.25f) : new Color(1f, 1f, 1f, 0.05f);\n        }\n    }\n\n    private void SelectTarget(string targetId)\n    {\n        _selectedTargetId = targetId;\n        _selectedAgentIds.Clear();\n\n        Debug.Log($\"[AssignPanelSelect] targetId={_selectedTargetId}\");\n\n        if (_mode == AssignPanelMode.Manage)\n        {\n            // Pull current assignment (prefer Manage Task, fallback legacy field)\n            var gc = GameController.I;\n            var node = (gc != null && !string.IsNullOrEmpty(_nodeId)) ? gc.GetNode(_nodeId) : null;\n            var mt = FindManageTask(node, targetId);\n            if (mt?.AssignedAgentIds != null)\n            {\n                foreach (var id in mt.AssignedAgentIds)\n                    _selectedAgentIds.Add(id);\n            }\n        }\n\n        RebuildAgentList();\n        RefreshTargetSelectionVisuals();\n        UpdateHeader();\n    }\n\n    private void RebuildAgentList()\n    {\n        // Clear\n        for (int i = 0; i < _agentItems.Count; i++)\n            if (_agentItems[i]) Destroy(_agentItems[i].gameObject);\n        _agentItems.Clear();\n\n        if (!agentListContent || !agentPickerItemPrefab)\n            return;\n\n        var gc = GameController.I;\n        if (gc == null) return;\n\n        var node = !string.IsNullOrEmpty(_nodeId) ? gc.GetNode(_nodeId) : null;\n        if (_mode == AssignPanelMode.Manage)\n        {\n            var anomaly = FindManagedAnomaly(node, _selectedTargetId);\n            if (anomaly == null)\n                return;\n\n            // Sync selection from Manage Task (source of truth), fallback legacy.\n            var mt = FindManageTask(node, anomaly.Id);\n            _selectedAgentIds.Clear();\n            if (mt?.AssignedAgentIds != null)\n                foreach (var id in mt.AssignedAgentIds) _selectedAgentIds.Add(id);\n        }\n\n        foreach (var ag in gc.State.Agents)\n        {\n            if (ag == null) continue;\n\n            // 先全部不选，避免池化残留\n            bool selected = false;\n\n            // Busy check (global): any active task (including Manage) OR legacy management occupancy.\n            bool busyTask = GameControllerTaskExt.AreAgentsBusy(gc, new List<string> { ag.Id });\n            \n            // Get busy text using BuildAgentBusyText\n            string busyText = Core.Sim.BuildAgentBusyText(gc.State, ag.Id);\n\n            // Allow clicking to deselect even if currently busy (soft lock)\n            bool isBusyOther = (!selected) && busyTask;\n\n            var go = Instantiate(agentPickerItemPrefab, agentListContent);\n            go.name = \"Agent_\" + ag.Id;\n\n            var item = go.GetComponent<AgentPickerItemView>();\n            if (item == null) item = go.AddComponent<AgentPickerItemView>();\n\n            // 先全部不选 - pass busyText to display\n            item.Bind(\n                ag.Id,\n                ag.Name,\n                BuildAgentAttrLine(ag),\n                isBusyOther,\n                false,\n                OnAgentClicked,\n                busyText);\n\n            // 再按预选集置 true\n            if (_selectedAgentIds.Contains(ag.Id))\n                item.SetSelected(true);\n\n            _agentItems.Add(item);\n        }\n\n        // Update confirm button\n        RefreshConfirmState();\n    }\n\n    private static string BuildAgentAttrLine(AgentState a)\n    {\n        if (a == null) return \"\";\n        return $\"P{a.Perception} O{a.Operation} R{a.Resistance} Pow{a.Power}\";\n    }\n\n    private void OnAgentClicked(string agentId)\n    {\n        if (string.IsNullOrEmpty(agentId)) return;\n\n        if (_selectedAgentIds.Contains(agentId))\n        {\n            _selectedAgentIds.Remove(agentId);\n        }\n        else\n        {\n            if (_selectedAgentIds.Count >= _slotsMax)\n            {\n                Debug.LogWarning($\"[TaskDef] manage slot selection exceeds max. slotsMax={_slotsMax}\");\n                return;\n            }\n            _selectedAgentIds.Add(agentId);\n        }\n\n        // Refresh only selection visuals\n        foreach (var it in _agentItems)\n        {\n            if (it == null) continue;\n            it.SetSelected(_selectedAgentIds.Contains(it.AgentId));\n        }\n\n        UpdateHeader();\n        RefreshConfirmState();\n    }\n\n    private void Confirm()\n    {\n        var gc = GameController.I;\n        if (gc == null) return;\n\n        if (_selectedAgentIds.Count < _slotsMin || _selectedAgentIds.Count > _slotsMax)\n        {\n            string message = $\"需要选择 {_slotsMin}-{_slotsMax} 名干员，目前为 {_selectedAgentIds.Count}。\";\n            if (hintText) hintText.text = message;\n            Debug.LogWarning($\"[TaskDef] manage slot selection invalid. count={_selectedAgentIds.Count} slotsMin={_slotsMin} slotsMax={_slotsMax}\");\n            return;\n        }\n\n        var targetId = _selectedTargetId ?? \"\";\n        var agentIds = _selectedAgentIds.ToList();\n\n        Debug.Log($\"[AssignPanelConfirm] targetId={targetId} agents={string.Join(\",\", agentIds)}\");\n\n        _onConfirm?.Invoke(targetId, agentIds);\n    }\n\n    private void RefreshConfirmState()\n    {\n        if (!confirmButton) return;\n        bool withinMin = _selectedAgentIds.Count >= _slotsMin;\n        bool withinMax = _selectedAgentIds.Count <= _slotsMax;\n        confirmButton.interactable = withinMin && withinMax;\n    }\n\n    private void UpdateHeader()\n    {\n        if (!headerText) return;\n        if (_mode != AssignPanelMode.Manage) return;\n\n        var gc = GameController.I;\n        var node = (gc != null && !string.IsNullOrEmpty(_nodeId)) ? gc.GetNode(_nodeId) : null;\n        var m = FindManagedAnomaly(node, _selectedTargetId);\n\n        if (m == null)\n        {\n            headerText.text = \"管理：未选择异常\";\n            return;\n        }\n\n        int mgr = 0;\n        var mt = FindManageTask(node, m.Id);\n        if (mt?.AssignedAgentIds != null) mgr = mt.AssignedAgentIds.Count;\n        string nodeName = \"\";\n        if (gc != null && !string.IsNullOrEmpty(_nodeId))\n        {\n            var n = gc.GetNode(_nodeId);\n            nodeName = n != null ? n.Name : \"\";\n        }\n\n        headerText.text = string.IsNullOrEmpty(nodeName)\n            ? $\"管理：{m.Name}  Lv{m.Level}  管理人数:{mgr}  累计负熵:{m.TotalNegEntropy}\"\n            : $\"管理：[{nodeName}] {m.Name}  Lv{m.Level}  管理人数:{mgr}  累计负熵:{m.TotalNegEntropy}\";\n    }\n\n    private void HandleManageConfirm(string targetId, List<string> agentIds)\n    {\n        var gc = GameController.I;\n        if (gc == null) return;\n\n        var node = !string.IsNullOrEmpty(_nodeId) ? gc.GetNode(_nodeId) : null;\n        var m = FindManagedAnomaly(node, targetId);\n        if (m == null) return;\n\n        // Write back as a formal Manage task.\n        var mt = gc.CreateManageTask(_nodeId, m.Id);\n        if (mt == null) return;\n\n        // If clearing selection, cancel/retreat the manage task to release occupancy.\n        if (agentIds.Count == 0)\n        {\n            gc.CancelOrRetreatTask(mt.Id);\n        }\n        else\n        {\n            gc.AssignTask(mt.Id, agentIds);\n\n            // Optional: set StartDay for UX (Sim will also set on first yield)\n            if (m.StartDay <= 0) m.StartDay = gc.State.Day;\n        }\n\n        // Update UI\n        RefreshUI();\n        gc.Notify();\n    }\n\n    // --------------------\n    // Data helpers\n    // --------------------\n\n    private static ManagedAnomalyState FindManagedAnomaly(NodeState node, string anomalyId)\n    {\n        if (node?.ManagedAnomalies == null || string.IsNullOrEmpty(anomalyId)) return null;\n        return node.ManagedAnomalies.FirstOrDefault(x => x != null && x.Id == anomalyId);\n    }\n\n    private static NodeTask FindManageTask(NodeState node, string anomalyId)\n    {\n        if (node?.Tasks == null || string.IsNullOrEmpty(anomalyId)) return null;\n\n        // Prefer active task\n        var active = node.Tasks.LastOrDefault(t => t != null && t.State == TaskState.Active && t.Type == TaskType.Manage && t.TargetManagedAnomalyId == anomalyId);\n        if (active != null) return active;\n\n        // Fallback: any manage task (history)\n        return node.Tasks.LastOrDefault(t => t != null && t.Type == TaskType.Manage && t.TargetManagedAnomalyId == anomalyId);\n    }\n\n    private static int GetCurrentManagerCount(NodeState node, string anomalyId)\n    {\n        int mgr = 0;\n        var mtForLabel = FindManageTask(node, anomalyId);\n        if (mtForLabel?.AssignedAgentIds != null) mgr = mtForLabel.AssignedAgentIds.Count;\n        return mgr;\n    }\n\n    private void SetListItemLabels(GameObject go, TargetEntry entry)\n    {\n        if (go == null || entry == null) return;\n\n        var labels = go.GetComponentsInChildren<TextMeshProUGUI>(true);\n        if (labels == null || labels.Length == 0) return;\n\n        if (labels.Length == 1)\n        {\n            labels[0].text = entry.title ?? \"\";\n            return;\n        }\n\n        TextMeshProUGUI titleLabel = null;\n        TextMeshProUGUI subtitleLabel = null;\n\n        foreach (var label in labels)\n        {\n            if (label == null) continue;\n            string name = label.name.ToLowerInvariant();\n            if (titleLabel == null && (name.Contains(\"title\") || name.Contains(\"name\") || name.Contains(\"label\")))\n                titleLabel = label;\n            if (subtitleLabel == null && (name.Contains(\"sub\") || name.Contains(\"desc\") || name.Contains(\"detail\")))\n                subtitleLabel = label;\n        }\n\n        titleLabel ??= labels[0];\n        if (labels.Length > 1 && subtitleLabel == null)\n            subtitleLabel = labels[1];\n\n        if (titleLabel) titleLabel.text = entry.title ?? \"\";\n        if (subtitleLabel) subtitleLabel.text = entry.subtitle ?? \"\";\n    }\n\n    private void RefreshTargetSelectionVisuals()\n    {\n        for (int i = 0; i < _anomalyItems.Count; i++)\n        {\n            var go = _anomalyItems[i];\n            if (go == null) continue;\n            string targetId = i < _currentTargets.Count ? _currentTargets[i]?.id : null;\n            bool selected = !string.IsNullOrEmpty(targetId) && targetId == _selectedTargetId;\n            SetListItemSelectedVisual(go, selected);\n        }\n    }\n\n    // 清空所有选中状态（agent/target/缓存）\n    private void ClearSelectionState()\n    {\n        _selectedAgentIds.Clear();\n        _selectedTargetId = null;\n        // 清空 agent item 选中\n        foreach (var item in _agentItems)\n        {\n            if (item != null) item.SetSelected(false);\n        }\n        // 清空 target item 选中\n        for (int i = 0; i < _anomalyItems.Count; i++)\n        {\n            var go = _anomalyItems[i];\n            if (go == null) continue;\n            SetListItemSelectedVisual(go, false);\n        }\n    }\n\n\n\n}\n// </EXPORT_BLOCK>"
        },
        {
            "id": 21,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "Prefab loaded."
        },
        {
            "id": 22,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        },
        {
            "id": 30,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\nusing System.Collections.Generic;\nusing Core;\nusing Data;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class EventPanel : MonoBehaviour\n{\n    [Header(\"Refs\")]\n    [SerializeField] private TMP_Text titleText;\n    [SerializeField] private TMP_Text descText;\n    [SerializeField] private Transform optionsRoot;\n    [SerializeField] private Button optionButtonTemplate;\n    [SerializeField] private TMP_Text resultText;\n    [SerializeField] private Button closeButton;\n\n    private EventInstance _eventInstance;\n    private EventDef _eventDef;\n    private List<EventOptionDef> _options = new();\n    private Func<string, string> _onChoose;\n    private Action _onClose;\n    private readonly List<Button> _spawnedOptionButtons = new();\n\n    private void OnEnable()\n    {\n        Debug.Log(\"[EventUI] EventPanel.OnEnable\");\n    }\n\n    public void Show(EventInstance ev, Func<string, string> onChoose, Action onClose = null)\n    {\n        var registry = DataRegistry.Instance;\n        Debug.Log($\"[EventUI] Show node={ev?.NodeId ?? \"<null>\"} eventInstanceId={ev?.EventInstanceId ?? \"<null>\"} eventDefId={ev?.EventDefId ?? \"<null>\"}\");\n        if (ev == null)\n        {\n            Debug.LogError(\"[EventUI] Show called with null EventInstance\");\n            return;\n        }\n\n        if (!registry.TryGetEvent(ev.EventDefId, out var eventDef))\n        {\n            Debug.LogError($\"[EventUI] Missing event def for {ev.EventDefId}\");\n            return;\n        }\n\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n\n        if (!ValidateRefsOrThrow()) return;\n\n        _eventInstance = ev;\n        _eventDef = eventDef;\n        _onChoose = onChoose;\n        _onClose = onClose;\n\n        registry.OptionsByEventId.TryGetValue(ev.EventDefId, out _options);\n        _options ??= new List<EventOptionDef>();\n\n        resultText.text = string.Empty;\n        resultText.gameObject.SetActive(false);\n\n        titleText.text = eventDef.title;\n        descText.text = eventDef.desc;\n\n        optionButtonTemplate.onClick.RemoveAllListeners();\n        optionButtonTemplate.gameObject.SetActive(false);\n\n        ClearSpawnedOptions();\n        BuildOptions(_options);\n        BindCloseButton();\n        LogShow(ev);\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n    }\n\n    private void ClearSpawnedOptions()\n    {\n        if (!optionsRoot) return;\n\n        _spawnedOptionButtons.Clear();\n\n        var toDestroy = new List<GameObject>();\n        for (int i = 0; i < optionsRoot.childCount; i++)\n        {\n            var child = optionsRoot.GetChild(i);\n            if (!child) continue;\n            if (optionButtonTemplate && child == optionButtonTemplate.transform) continue;\n            toDestroy.Add(child.gameObject);\n        }\n\n        foreach (var go in toDestroy)\n        {\n            Destroy(go);\n        }\n    }\n\n    private void BuildOptions(List<EventOptionDef> options)\n    {\n        if (!optionsRoot || !optionButtonTemplate) return;\n        options ??= new List<EventOptionDef>();\n\n        foreach (var option in options)\n        {\n            if (option == null) continue;\n\n            var button = Instantiate(optionButtonTemplate, optionsRoot);\n            button.onClick.RemoveAllListeners();\n            button.gameObject.SetActive(true);\n\n            var label = button.GetComponentInChildren<TMP_Text>(true);\n            if (label) label.text = option.text;\n\n            string optionId = option.optionId;\n            button.onClick.AddListener(() => OnOptionClicked(optionId));\n\n            _spawnedOptionButtons.Add(button);\n        }\n    }\n\n    private void OnOptionClicked(string optionId)\n    {\n        LogClick(optionId);\n        var result = _onChoose?.Invoke(optionId);\n        ShowResult(string.IsNullOrEmpty(result) ? \"事件已处理\" : result);\n    }\n\n    private void ShowResult(string result)\n    {\n        resultText.text = result;\n        resultText.gameObject.SetActive(true);\n    }\n\n    private void BindCloseButton()\n    {\n        if (!closeButton) return;\n        closeButton.onClick.RemoveAllListeners();\n        closeButton.onClick.AddListener(() =>\n        {\n            Hide();\n            _onClose?.Invoke();\n        });\n    }\n\n    private bool ValidateRefsOrThrow()\n    {\n        var missing = new List<string>();\n        if (!titleText) missing.Add(nameof(titleText));\n        if (!descText) missing.Add(nameof(descText));\n        if (!optionsRoot) missing.Add(nameof(optionsRoot));\n        if (!optionButtonTemplate) missing.Add(nameof(optionButtonTemplate));\n        if (!resultText) missing.Add(nameof(resultText));\n        if (!closeButton) missing.Add(nameof(closeButton));\n\n        if (missing.Count == 0) return true;\n\n        Debug.LogError($\"[EventUI] Missing refs: {string.Join(\", \", missing)}\");\n        return false;\n    }\n\n    private void LogShow(EventInstance ev)\n    {\n        int pendingCount = 0;\n        if (GameController.I != null && !string.IsNullOrEmpty(ev.NodeId))\n        {\n            var node = GameController.I.GetNode(ev.NodeId);\n            pendingCount = node?.PendingEvents?.Count ?? 0;\n        }\n\n        int optionCount = _options?.Count ?? 0;\n        Debug.Log($\"[EventUI] Show node={ev.NodeId} eventInstanceId={ev.EventInstanceId} eventDefId={ev.EventDefId} options={optionCount} pendingCount={pendingCount}\");\n    }\n\n    private void LogClick(string optionId)\n    {\n        if (_eventInstance == null || _eventDef == null) return;\n        Debug.Log($\"[EventUI] Click option={optionId} node={_eventInstance.NodeId} eventInstanceId={_eventInstance.EventInstanceId} eventDefId={_eventInstance.EventDefId}\");\n    }\n}"
        },
        {
            "id": 31,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "Prefab loaded."
        },
        {
            "id": 32,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        }
    ]
}