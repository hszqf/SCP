{
    "batch_id": "investigate_known_and_assignpanel_02",
    "results": [
        {
            "id": 1,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Core/GameState (v3 - N tasks)\n// Source target: Assets/Scripts/Core/GameState.cs\n// Goal: Support unlimited per-node tasks (investigate/contain) via NodeState.Tasks.\n// Notes:\n// - Legacy single-task fields are kept temporarily for compatibility with existing UI/code.\n// - New systems should only use NodeState.Tasks.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace Core\n{\n    // Keep for legacy UI and map display. In N-task model, task state is derived from NodeState.Tasks.\n    public enum NodeStatus { Calm, Secured }\n\n    // Legacy event kind (PendingEvent). New node events use EventInstance.\n    public enum EventKind { Investigate, Contain }\n\n    public enum TaskType { Investigate, Contain, Manage }\n    public enum TaskState { Active, Completed, Cancelled }\n\n    [Serializable]\n    public class AgentState\n    {\n        public string Id;\n        public string Name;\n\n        public int Perception = 5;\n        public int Operation = 5;\n        public int Resistance = 5;\n        public int Power = 5;\n    }\n\n    [Serializable]\n    public class ContainableItem\n    {\n        public string Id;\n        public string Name;\n        public int Level = 1;\n        public string AnomalyId;\n    }\n\n    // 收容后进入“已收藏异常”，可被分配干员进行长期管理，按天产出负熵。\n    [Serializable]\n    public class ManagedAnomalyState\n    {\n        public string Id;\n        public string Name;\n        public int Level = 1;\n        public string AnomalyId;\n        public string AnomalyClass;\n\n        // 左侧“已收藏异常”列表使用（后续可做收藏/取消收藏筛选）\n        public bool Favorited = true;\n\n        // 第一次开始管理的日期（用于统计/成长）\n        public int StartDay;\n\n        // 累计产出\n        public int TotalNegEntropy;\n    }\n\n    [Serializable]\n    public class NodeTask\n    {\n        public string Id;\n        public TaskType Type;\n        public TaskState State = TaskState.Active;\n        public string TaskDefId;\n\n        // 0..1\n        public float Progress = 0f;\n\n        // 预定占用：progress==0 也算占用。\n        public List<string> AssignedAgentIds = new();\n\n        // Only for containment tasks: which containable we are trying to contain.\n        public string TargetContainableId;\n\n        // Investigate: which news clue we are targeting (empty => generic investigation).\n        public string TargetNewsId;\n\n        // Investigate/Contain: anomaly id associated with this task (optional).\n        public string SourceAnomalyId;\n\n        // Only for management tasks: which managed anomaly we are managing.\n        public string TargetManagedAnomalyId;\n\n        public int CreatedDay;\n        public int CompletedDay;\n\n        public bool IsStarted => Progress > 0.0001f;\n    }\n\n    [Serializable]\n    public class NodeState\n    {\n        public string Id;\n        public string Name;\n        public List<string> Tags = new();\n\n        // 0..1 百分比坐标：左下(0,0) 右上(1,1)\n        public float X;\n        public float Y;\n\n        // Node-level status is now coarse. Tasks are in Tasks list.\n        public NodeStatus Status = NodeStatus.Calm;\n\n        public bool HasAnomaly = false;\n        public int AnomalyLevel = 0;\n        public List<string> ActiveAnomalyIds = new();\n\n        // 调查产出：可收容目标列表（调查完成后写入）\n        public List<ContainableItem> Containables = new();\n        // 收容产出：已收容目标列表（收容完成后写入）\n        public List<ManagedAnomalyState> ManagedAnomalies = new List<ManagedAnomalyState>();\n\n\n        // ===== NEW: Unlimited tasks =====\n        public List<NodeTask> Tasks = new();\n\n        // ===== Node-scoped state =====\n        public int LocalPanic = 0;\n        public int Population = 10;\n        public List<EventInstance> PendingEvents = new();\n        public bool HasPendingEvent => PendingEvents != null && PendingEvents.Count > 0;\n\n        // ===== Legacy fields (temporary) =====\n        // Kept so existing UI/code can compile during migration. Do not use for new features.\n        public List<string> AssignedAgentIds = new List<string>(); // legacy squad\n        public float InvestigateProgress = 0f; // legacy 0..1\n        public float ContainProgress = 0f;     // legacy 0..1\n    }\n\n    [Serializable]\n    public class DecisionOption\n    {\n        public string Id;\n        public string Text;\n\n        // \"Perception\" / \"Operation\" / \"Resistance\" / \"Power\"\n        public string CheckAttr;\n        public int Threshold;\n        public float BaseSuccess = 0.5f;\n\n        public int MoneyOnSuccess = 0;\n        public int MoneyOnFail = 0;\n        public int PanicOnSuccess = 0;\n        public int PanicOnFail = 0;\n\n        public float ProgressDeltaOnSuccess = 0.02f;\n        public float ProgressDeltaOnFail = -0.06f;\n    }\n\n    [Serializable]\n    public class PendingEvent\n    {\n        public string Id;\n        public string NodeId;\n        public EventKind Kind;\n\n        public string Title;\n        public string Desc;\n\n        public List<DecisionOption> Options = new();\n    }\n\n    [Serializable]\n    public class GameState\n    {\n        public int Day = 1;\n        public int Money = 0;\n        public float WorldPanic = 0f;\n\n        // 预留字段：Intel（暂不结算）\n        public int Intel = 0;\n\n        // 新货币：负熵（由“管理异常”系统每日产出）\n        public int NegEntropy = 0;\n\n        // 已收藏/已收容异常的长期管理状态（Legacy/Deprecated）\n        // Node-scoped source of truth is NodeState.ManagedAnomalies.\n        public List<ManagedAnomalyState> ManagedAnomalies = new List<ManagedAnomalyState>();\n\n        public List<NodeState> Nodes = new();\n        public List<AgentState> Agents = new();\n\n        public List<PendingEvent> PendingEvents = new();\n        public List<string> News = new();\n        public List<NewsInstance> NewsLog = new();\n\n        public Dictionary<string, int> EventFiredCounts = new();\n        public Dictionary<string, int> EventLastFiredDay = new();\n        public Dictionary<string, int> NewsFiredCounts = new();\n        public Dictionary<string, int> NewsLastFiredDay = new();\n    }\n}\n// </EXPORT_BLOCK>"
        },
        {
            "id": 2,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Core/Sim (v4 - data driven events)\n// Source: Assets/Scripts/Core/Sim.cs\n// Goal: Load all game data from DataRegistry and drive events/effects via config.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Data;\nusing UnityEngine;\nusing Random = System.Random;\n\nnamespace Core\n{\n    public static class Sim\n    {\n        private const string RequirementAny = \"ANY\";\n        private const string RandomDailySource = \"RandomDaily\";\n\n        public static event Action OnIgnorePenaltyApplied;\n\n        private static readonly HashSet<TaskType> WarnedMissingYieldFields = new();\n        private static readonly HashSet<TaskType> WarnedUnknownYieldKey = new();\n        private static readonly HashSet<string> WarnedDifficultyAnomalies = new();\n\n        public static void StepDay(GameState s, Random rng)\n        {\n            var registry = DataRegistry.Instance;\n\n            s.Day += 1;\n            s.News.Add($\"Day {s.Day}: 日结算开始\");\n\n            // 0) 异常生成（节点维度）\n            foreach (var n in s.Nodes)\n            {\n                if (n == null) continue;\n                if (n.Status == NodeStatus.Calm && !n.HasAnomaly)\n                {\n                    if (rng.NextDouble() < 0.15)\n                    {\n                        var anomalyId = PickRandomAnomalyId(registry, rng);\n                        if (!string.IsNullOrEmpty(anomalyId))\n                        {\n                            EnsureActiveAnomaly(n, anomalyId, registry);\n                            s.News.Add($\"- {n.Name} 出现异常迹象：{anomalyId}\");\n                        }\n                    }\n                }\n            }\n\n            // 1) 推进任务（任务维度：同节点可并行 N 个任务）\n            foreach (var n in s.Nodes)\n            {\n                if (n?.Tasks == null || n.Tasks.Count == 0) continue;\n\n                // 推进所有 Active 任务（按事件阻塞策略判断）\n                for (int i = 0; i < n.Tasks.Count; i++)\n                {\n                    var t = n.Tasks[i];\n                    if (t == null) continue;\n                    if (t.State != TaskState.Active) continue;\n                    if (t.AssignedAgentIds == null || t.AssignedAgentIds.Count == 0) continue;\n\n                    if (IsTaskBlockedByEvents(s, n, t, registry))\n                        continue;\n\n                    var squad = GetAssignedAgents(s, t.AssignedAgentIds);\n                    if (squad.Count == 0) continue;\n\n                    float baseDelta = CalcDailyProgressDelta(t, squad, rng, registry);\n                    string anomalyId = GetTaskAnomalyId(n, t);\n                    int diff = 1;\n                    if (t.Type == TaskType.Investigate || t.Type == TaskType.Contain)\n                    {\n                        diff = GetTaskDifficulty(anomalyId, t.Type, registry);\n                    }\n\n                    float effDelta = baseDelta / Math.Max(1, diff);\n                    int manageRisk = (t.Type == TaskType.Manage) ? GetManageRisk(anomalyId, registry) : 0;\n\n                    // Manage tasks are LONG-RUNNING: progress is only used as a \"started\" flag (0 vs >0).\n                    // They should never auto-complete.\n                    if (t.Type == TaskType.Manage)\n                    {\n                        float beforeManage = t.Progress;\n                        t.Progress = Math.Max(t.Progress, 0f);\n                        t.Progress = Clamp01(t.Progress + effDelta);\n                        if (t.Progress >= 1f) t.Progress = 0.99f;\n                        if (Math.Abs(t.Progress - beforeManage) > 0.0001f)\n                        {\n                            Debug.Log($\"[TaskProgress] day={s.Day} taskId={t.Id} type={t.Type} anomalyId={anomalyId} diff={diff} baseDelta={baseDelta:0.00} effDelta={effDelta:0.00} risk={manageRisk} progress={t.Progress:0.00}/1 (baseDays=1)\");\n                        }\n                        continue;\n                    }\n\n                    int baseDays = Math.Max(1, registry.GetTaskBaseDaysWithWarn(t.Type, 1));\n                    float before = t.Progress;\n                    t.Progress = Mathf.Clamp(t.Progress + effDelta, 0f, baseDays);\n                    if (Math.Abs(t.Progress - before) > 0.0001f)\n                    {\n                        Debug.Log($\"[TaskProgress] day={s.Day} taskId={t.Id} type={t.Type} anomalyId={anomalyId} diff={diff} baseDelta={baseDelta:0.00} effDelta={effDelta:0.00} progress={t.Progress:0.00}/{baseDays} (baseDays={baseDays})\");\n                    }\n\n                    if (t.Progress >= baseDays)\n                    {\n                        CompleteTask(s, n, t, rng, registry);\n                    }\n                }\n            }\n\n            // 1.5) 收容后管理（负熵产出）\n            StepManageTasks(s, rng, registry);\n\n            // 1.75) 任务日结算产出（TaskDefs.yieldKey / yieldPerDay）\n            StepTaskDailyYield(s, registry);\n\n            // 2) 不处理的后果（按 IgnoreApplyMode 执行）\n            ApplyIgnorePenaltyOnDayEnd(s, registry);\n\n            // 2.5) 事件自动关闭（按 autoResolveAfterDays）\n            AutoResolvePendingEventsOnDayEnd(s, registry);\n\n            // 3) RandomDaily 事件生成\n            GenerateRandomDailyEvents(s, rng, registry);\n\n            // 3.5) RandomDaily 新闻生成\n            GenerateRandomDailyNews(s, rng, registry);\n\n            // 4) 经济 & 世界恐慌（全局）\n            float popToMoneyRate = registry.GetBalanceFloatWithWarn(\"PopToMoneyRate\", 0f);\n            int wagePerAgentPerDay = registry.GetBalanceIntWithWarn(\"WagePerAgentPerDay\", 0);\n            int maintenanceDefault = registry.GetBalanceIntWithWarn(\"ContainedAnomalyMaintenanceDefault\", 0);\n            int clampMoneyMin = registry.GetBalanceIntWithWarn(\"ClampMoneyMin\", 0);\n            float clampWorldPanicMin = registry.GetBalanceFloatWithWarn(\"ClampWorldPanicMin\", 0f);\n\n            int moneyBefore = s.Money;\n            int income = 0;\n            int maintenance = 0;\n            int safeNodeCount = 0;\n            float worldPanicAdd = 0f;\n\n            foreach (var node in s.Nodes)\n            {\n                if (node == null) continue;\n\n                income += Mathf.FloorToInt(node.Population * popToMoneyRate);\n\n                // Safe node definition (current): no uncontained anomalies on this node.\n                bool hasUncontained = node.Status != NodeStatus.Secured && node.ActiveAnomalyIds != null && node.ActiveAnomalyIds.Count > 0;\n                if (!hasUncontained) safeNodeCount++;\n\n                if (hasUncontained)\n                {\n                    foreach (var anomalyId in node.ActiveAnomalyIds)\n                    {\n                        if (string.IsNullOrEmpty(anomalyId))\n                        {\n                            Debug.LogWarning(\"[WARN] Missing anomalyId for world panic calculation. Using fallback=0.\");\n                            continue;\n                        }\n                        worldPanicAdd += registry.GetAnomalyFloatWithWarn(anomalyId, \"worldPanicPerDayUncontained\", 0f);\n                    }\n                }\n\n                if (node.ManagedAnomalies == null) continue;\n                foreach (var managed in node.ManagedAnomalies)\n                {\n                    if (managed == null) continue;\n                    if (string.IsNullOrEmpty(managed.AnomalyId))\n                    {\n                        Debug.LogWarning($\"[WARN] Managed anomaly {managed.Id} missing anomalyId. Using default maintenance={maintenanceDefault}.\");\n                        maintenance += maintenanceDefault;\n                        continue;\n                    }\n                    maintenance += registry.GetAnomalyIntWithWarn(managed.AnomalyId, \"maintenanceCostPerDay\", maintenanceDefault);\n                }\n            }\n\n            int wage = (s.Agents?.Count ?? 0) * wagePerAgentPerDay;\n            int optionCost = 0; // TODO: hook event option costs if/when EffectOps expose them.\n            int moneyAfter = moneyBefore + income - wage - maintenance - optionCost;\n            if (moneyAfter < clampMoneyMin) moneyAfter = clampMoneyMin;\n            s.Money = moneyAfter;\n\n            Debug.Log($\"[Economy] day={s.Day} income={income} wage={wage} maint={maintenance} option={optionCost} moneyBefore={moneyBefore} moneyAfter={moneyAfter}\");\n\n            float dailyDecay = registry.GetBalanceFloatWithWarn(\"DailyWorldPanicDecay\", 0f);\n            float decayPerSafeNode = registry.GetBalanceFloatWithWarn(\"WorldPanicDecayPerSafeNodePerDay\", 0f);\n            float worldPanicDecay = dailyDecay + safeNodeCount * decayPerSafeNode;\n            float worldPanicBefore = s.WorldPanic;\n            float worldPanicAfter = worldPanicBefore + worldPanicAdd - worldPanicDecay;\n            if (worldPanicAfter < clampWorldPanicMin) worldPanicAfter = clampWorldPanicMin;\n            s.WorldPanic = worldPanicAfter;\n\n            float failThreshold = registry.GetBalanceFloatWithWarn(\"WorldPanicFailThreshold\", 0f);\n            Debug.Log($\"[WorldPanic] day={s.Day} add={worldPanicAdd:0.##} decay={worldPanicDecay:0.##} safe={safeNodeCount} before={worldPanicBefore:0.##} after={worldPanicAfter:0.##} threshold={failThreshold:0.##}\");\n\n            if (s.WorldPanic >= failThreshold && GameController.I != null)\n            {\n                GameController.I.MarkGameOver($\"reason=WorldPanic day={s.Day} value={s.WorldPanic:0.##} threshold={failThreshold:0.##}\");\n            }\n\n            s.News.Add($\"Day {s.Day} 结束\");\n        }\n\n        public static (bool success, string text) ResolveEvent(GameState s, string nodeId, string eventInstanceId, string optionId, Random rng)\n        {\n            var registry = DataRegistry.Instance;\n            var node = s.Nodes.FirstOrDefault(n => n != null && n.Id == nodeId);\n            if (node == null) return (false, \"节点不存在\");\n            if (node.PendingEvents == null || node.PendingEvents.Count == 0) return (false, \"节点无事件\");\n\n            var ev = node.PendingEvents.FirstOrDefault(e => e != null && e.EventInstanceId == eventInstanceId);\n            if (ev == null) return (false, \"事件不存在\");\n            if (!registry.TryGetEvent(ev.EventDefId, out var eventDef)) return (false, \"事件配置不存在\");\n            if (!registry.TryGetOption(ev.EventDefId, optionId, out var optionDef)) return (false, \"选项不存在\");\n\n            var originTask = TryGetOriginTask(s, ev.SourceTaskId, out var originNode) ? originNode?.Tasks?.FirstOrDefault(t => t != null && t.Id == ev.SourceTaskId) : null;\n\n            var affects = ResolveAffects(eventDef, optionDef, registry);\n            var ctx = new EffectContext\n            {\n                State = s,\n                Node = node,\n                OriginTask = originTask,\n                EventDefId = ev.EventDefId,\n                OptionId = optionId,\n            };\n            int effectsApplied = EffectOpExecutor.ApplyEffect(optionDef.effectId, ctx, affects);\n\n            node.PendingEvents.Remove(ev);\n\n            Debug.Log($\"[EventResolve] node={node.Id} inst={ev.EventInstanceId} def={ev.EventDefId} option={optionDef.optionId} effectsApplied={effectsApplied}\");\n\n            s.News.Add($\"- {node.Name} 事件处理：{eventDef.title} -> {optionDef.text}\");\n\n            var resultText = string.IsNullOrEmpty(optionDef.resultText) ? BuildEffectSummary(optionDef.effectId, affects) : optionDef.resultText;\n            if (string.IsNullOrEmpty(resultText)) resultText = optionDef.text;\n            if (string.IsNullOrEmpty(resultText)) resultText = \"事件已处理\";\n            return (true, resultText);\n        }\n\n        private static void GenerateRandomDailyEvents(GameState s, Random rng, DataRegistry registry)\n        {\n            if (s == null || s.Nodes == null) return;\n\n            var randomDailyDefs = registry.EventsById.Values\n                .Where(def => def != null &&\n                              !string.IsNullOrEmpty(def.eventDefId) &&\n                              string.Equals(def.source, RandomDailySource, StringComparison.OrdinalIgnoreCase))\n                .ToList();\n\n            int taskCtxChecked = 0;\n            int taskFired = 0;\n            int nodeCtxChecked = 0;\n            int nodeFired = 0;\n\n            var firedCounts = s.EventFiredCounts ??= new Dictionary<string, int>();\n            var lastFiredDay = s.EventLastFiredDay ??= new Dictionary<string, int>();\n\n            foreach (var node in s.Nodes)\n            {\n                if (node?.Tasks == null || node.Tasks.Count == 0) continue;\n\n                foreach (var task in node.Tasks)\n                {\n                    if (task == null || task.State != TaskState.Active) continue;\n                    if (task.Type != TaskType.Investigate && task.Type != TaskType.Contain && task.Type != TaskType.Manage) continue;\n\n                    taskCtxChecked += 1;\n                    int pendingBefore = node.PendingEvents?.Count ?? 0;\n                    string ctxTaskTypeKey = GetTaskTypeKey(task.Type);\n                    string ctxAnomalyId = GetTaskAnomalyId(node, task);\n\n                    if (pendingBefore > 0)\n                    {\n                        Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll=0 p=0 allow=false reason=pendingEvents pendingBefore={pendingBefore}\");\n                        continue;\n                    }\n\n                    var matched = GetRandomDailyMatches(randomDailyDefs, s.Day, node.Id, ctxTaskTypeKey, ctxAnomalyId, firedCounts, lastFiredDay, requireAnomalyAny: false);\n                    Debug.Log($\"[EventPool] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} candidates={randomDailyDefs.Count} matched={matched.Count}\");\n\n                    if (matched.Count == 0)\n                    {\n                        Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll=0 p=0 allow=false reason=noMatch pendingBefore={pendingBefore}\");\n                        continue;\n                    }\n\n                    float pContext = Mathf.Clamp01(matched.Max(def => def.p));\n                    double roll = rng.NextDouble();\n                    bool allow = roll <= pContext;\n                    string reason = allow ? \"trigger\" : \"rollTooHigh\";\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll={roll:0.00} p={pContext:0.00} allow={allow} reason={reason} pendingBefore={pendingBefore}\");\n\n                    if (!allow) continue;\n                    if (!TryPickWeighted(matched, rng, out var picked)) continue;\n\n                    var instance = EventInstanceFactory.Create(picked.eventDefId, node.Id, s.Day, task.Id, ctxAnomalyId, RandomDailySource);\n                    AddEventToNode(node, instance);\n                    UpdateEventFireTracking(s.Day, picked.eventDefId, firedCounts, lastFiredDay);\n                    taskFired += 1;\n\n                    Debug.Log($\"[EventGen] day={s.Day} ctx=Task node={node.Id} eventDefId={picked.eventDefId} inst={instance.EventInstanceId} cause={RandomDailySource} taskId={task.Id} anomalyId={ctxAnomalyId ?? \"none\"}\");\n                    s.News.Add($\"- {node.Name} 发生事件：{picked.title}\");\n                }\n            }\n\n            foreach (var node in s.Nodes)\n            {\n                if (node == null) continue;\n                nodeCtxChecked += 1;\n\n                int pendingBefore = node.PendingEvents?.Count ?? 0;\n                if (pendingBefore > 0)\n                {\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll=0 p=0 allow=false reason=pendingEvents pendingBefore={pendingBefore}\");\n                    continue;\n                }\n\n                var matched = GetRandomDailyMatches(randomDailyDefs, s.Day, node.Id, RequirementAny, null, firedCounts, lastFiredDay, requireAnomalyAny: true);\n                Debug.Log($\"[EventPool] day={s.Day} ctx=Node node={node.Id} taskId=none candidates={randomDailyDefs.Count} matched={matched.Count}\");\n\n                if (matched.Count == 0)\n                {\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll=0 p=0 allow=false reason=noMatch pendingBefore={pendingBefore}\");\n                    continue;\n                }\n\n                float pContext = Mathf.Clamp01(matched.Max(def => def.p));\n                double roll = rng.NextDouble();\n                bool allow = roll <= pContext;\n                string reason = allow ? \"trigger\" : \"rollTooHigh\";\n                Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll={roll:0.00} p={pContext:0.00} allow={allow} reason={reason} pendingBefore={pendingBefore}\");\n\n                if (!allow) continue;\n                if (!TryPickWeighted(matched, rng, out var picked)) continue;\n\n                var instance = EventInstanceFactory.Create(picked.eventDefId, node.Id, s.Day, null, null, RandomDailySource);\n                AddEventToNode(node, instance);\n                UpdateEventFireTracking(s.Day, picked.eventDefId, firedCounts, lastFiredDay);\n                nodeFired += 1;\n\n                Debug.Log($\"[EventGen] day={s.Day} ctx=Node node={node.Id} eventDefId={picked.eventDefId} inst={instance.EventInstanceId} cause={RandomDailySource} taskId=none anomalyId=none\");\n                s.News.Add($\"- {node.Name} 发生事件：{picked.title}\");\n            }\n\n            Debug.Log($\"[RandomDailySummary] day={s.Day} taskCtxChecked={taskCtxChecked} taskFired={taskFired} nodeCtxChecked={nodeCtxChecked} nodeFired={nodeFired}\");\n        }\n\n        private static void GenerateRandomDailyNews(GameState s, Random rng, DataRegistry registry)\n        {\n            if (s == null || s.Nodes == null) return;\n\n            var randomDailyDefs = registry.NewsDefsById.Values\n                .Where(def => def != null &&\n                              !string.IsNullOrEmpty(def.newsDefId) &&\n                              string.Equals(def.source, RandomDailySource, StringComparison.OrdinalIgnoreCase))\n                .ToList();\n\n            int nodeAnomCtxChecked = 0;\n            int nodeAnomPicked = 0;\n            int nodeAnomEmitted = 0;\n            int nodeCtxChecked = 0;\n            int nodePicked = 0;\n            int nodeEmitted = 0;\n\n            var firedCounts = s.NewsFiredCounts ??= new Dictionary<string, int>();\n            var lastFiredDay = s.NewsLastFiredDay ??= new Dictionary<string, int>();\n\n            foreach (var node in s.Nodes)\n            {\n                if (node?.ActiveAnomalyIds == null || node.ActiveAnomalyIds.Count == 0) continue;\n\n                foreach (var anomalyId in node.ActiveAnomalyIds)\n                {\n                    if (string.IsNullOrEmpty(anomalyId)) continue;\n                    nodeAnomCtxChecked += 1;\n\n                    var matched = GetRandomDailyNewsMatches(randomDailyDefs, s.Day, node.Id, anomalyId, firedCounts, lastFiredDay, requireAnomalyAny: false);\n                    if (matched.Count == 0) continue;\n\n                    if (!TryPickWeightedNews(matched, rng, out var picked)) continue;\n                    nodeAnomPicked += 1;\n\n                    double roll = rng.NextDouble();\n                    bool emit = roll <= picked.p;\n                    string reason = emit ? \"Picked\" : \"RolledAboveP\";\n                    Debug.Log($\"[NewsPick] day={s.Day} ctx=NodeAnom nodeId={node.Id} anomalyId={anomalyId} newsDefId={picked.newsDefId} weight={picked.weight} p={picked.p:0.00} roll={roll:0.00} emit={(emit ? 1 : 0)} reason={reason}\");\n                    if (!emit) continue;\n\n                    string sourceAnomalyId = IsRequirementAny(picked.requiresAnomalyId) ? null : anomalyId;\n                    var instance = NewsInstanceFactory.Create(picked.newsDefId, node.Id, sourceAnomalyId, RandomDailySource);\n                    AddNewsToLog(s, instance);\n                    UpdateNewsFireTracking(s.Day, picked.newsDefId, firedCounts, lastFiredDay);\n                    nodeAnomEmitted += 1;\n\n                    Debug.Log($\"[NewsGen] day={s.Day} ctx=NodeAnom nodeId={node.Id} anomalyId={anomalyId} newsDefId={picked.newsDefId} instId={instance.Id} cause={RandomDailySource}\");\n                }\n            }"
        },
        {
            "id": 3,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\n\nnamespace Core\n{\n    [Serializable]\n    public class NewsInstance\n    {\n        public string Id;\n        public string NewsDefId;\n        public string NodeId;\n        public string SourceAnomalyId;\n        public string CauseType;\n        public int AgeDays;\n        public bool IsResolved;\n        public int ResolvedDay;\n    }\n\n    public static class NewsInstanceFactory\n    {\n        public static NewsInstance Create(string newsDefId, string nodeId, string sourceAnomalyId, string causeType)\n        {\n            return new NewsInstance\n            {\n                Id = $\"NEWS_{Guid.NewGuid():N}\",\n                NewsDefId = newsDefId,\n                NodeId = nodeId,\n                SourceAnomalyId = sourceAnomalyId,\n                CauseType = causeType,\n                AgeDays = 0,\n                IsResolved = false,\n                ResolvedDay = 0,\n            };\n        }\n    }\n}"
        },
        {
            "id": 4,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Assets/Scripts/UI/AnomalyManagePanel.cs\n// Purpose: Management panel for contained anomalies (NODE-SCOPED).\n// - Left: favorited managed anomalies of a specific node (NodeState.ManagedAnomalies)\n// - Right: agent list (reuses AgentPickerItemView) to assign managers\n// - Confirm creates/updates a NodeTask (TaskType.Manage) and assigns agents via NodeTask.AssignedAgentIds.\n//   Sim awards daily NegEntropy based on active Manage tasks.\n//\n// Data scope note:\n// - Containables & post-containment management belong to the node that contained them.\n// - Global currency NegEntropy is accumulated in GameState, but per-anomaly state is stored under NodeState.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Core;\nusing Data;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class AnomalyManagePanel : MonoBehaviour\n{\n    public class TargetEntry\n    {\n        public string id;\n        public string title;\n        public string subtitle;\n        public bool disabled;\n    }\n\n    private enum AssignPanelMode\n    {\n        Manage,\n        Generic\n    }\n\n    [Header(\"Left: Anomaly list\")]\n    [SerializeField] private Transform anomalyListContent;\n    [SerializeField] private GameObject anomalyListItemPrefab; // must have Button + TMP_Text named \"Label\" (or any TMP_Text)\n\n    [Header(\"Right: Agent list (AgentPickerItemView)\")]\n    [SerializeField] private Transform agentListContent;\n    [SerializeField] private GameObject agentPickerItemPrefab; // prefab with AgentPickerItemView\n\n    [Header(\"Actions\")]\n    [SerializeField] private Button confirmButton;\n    [SerializeField] private Button closeButton;\n    [SerializeField] private TMP_Text headerText; // optional\n    [SerializeField] private TMP_Text hintText;   // optional\n\n    private readonly List<GameObject> _anomalyItems = new();\n    private readonly List<AgentPickerItemView> _agentItems = new();\n    private readonly List<TargetEntry> _currentTargets = new();\n\n    private string _selectedTargetId;\n    private string _nodeId; // management context node id (set by UIPanelRoot.ManageNodeId)\n    private readonly HashSet<string> _selectedAgentIds = new();\n    private int _slotsMin = 1;\n    private int _slotsMax = int.MaxValue;\n    private AssignPanelMode _mode = AssignPanelMode.Manage;\n    private Action<string, List<string>> _onConfirm;\n\n    void Awake()\n    {\n        if (closeButton)\n        {\n            closeButton.onClick.RemoveAllListeners();\n            closeButton.onClick.AddListener(Hide);\n        }\n\n        if (confirmButton)\n        {\n            confirmButton.onClick.RemoveAllListeners();\n            confirmButton.onClick.AddListener(Confirm);\n        }\n    }\n\n    void OnEnable()\n    {\n        var root = UIPanelRoot.I;\n        _nodeId = root != null ? root.ManageNodeId : null;\n        RefreshUI();\n    }\n\n    public void Show()\n    {\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n        RefreshUI();\n    }\n\n    // Optional explicit node binding (recommended if you call panel directly)\n    public void Show(string nodeId)\n    {\n        ShowForNode(nodeId);\n    }\n\n    public void Hide()\n    {\n        gameObject.SetActive(false);\n        GameControllerTaskExt.LogBusySnapshot(GameController.I, \"AnomalyManagePanel.Hide\");\n    }\n\n    public void ShowForNode(string nodeId)\n    {\n        _nodeId = nodeId;\n        gameObject.SetActive(true);\n        transform.SetAsLastSibling();\n        RefreshUI();\n    }\n\n    // --------------------\n    // Refresh\n    // --------------------\n\n    public void RefreshUI()\n    {\n        var gc = GameController.I;\n        if (gc == null) return;\n        var registry = DataRegistry.Instance;\n        (_slotsMin, _slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Manage, 1, int.MaxValue);\n\n        var node = !string.IsNullOrEmpty(_nodeId) ? gc.GetNode(_nodeId) : null;\n        var list = GetFavoritedAnomalies(node);\n\n        // Keep selection valid\n        if (string.IsNullOrEmpty(_selectedTargetId) || !list.Any(x => x.Id == _selectedTargetId))\n            _selectedTargetId = list.FirstOrDefault()?.Id;\n        if (list.Count == 0)\n        {\n            _selectedTargetId = null;\n            _selectedAgentIds.Clear();\n        }\n\n        var targets = list\n            .Select(a => new TargetEntry\n            {\n                id = a.Id,\n                title = BuildAnomalyLabel(a, GetCurrentManagerCount(node, a.Id)),\n                subtitle = null,\n                disabled = false\n            })\n            .ToList();\n\n        string hint = \"\";\n        if (list.Count == 0)\n        {\n            if (string.IsNullOrEmpty(_nodeId)) hint = \"管理面板缺少节点上下文（ManageNodeId 为空）。\";\n            else hint = \"该节点暂无已收容异常。请先完成收容。\";\n        }\n        else\n        {\n            hint = \"选择异常，然后分配干员开始管理（每日产出负熵）。\";\n        }\n\n        ShowGenericInternal(\"管理：选择异常\", hint, targets, _slotsMin, _slotsMax, HandleManageConfirm, \"Manage\");\n        UpdateHeader();\n    }\n\n    private static List<ManagedAnomalyState> GetFavoritedAnomalies(NodeState node)\n    {\n        if (node?.ManagedAnomalies == null) return new List<ManagedAnomalyState>();\n        return node.ManagedAnomalies\n            .Where(x => x != null && x.Favorited)\n            .OrderByDescending(x => x.Level)\n            .ThenBy(x => x.Name)\n            .ToList();\n    }\n\n    public void ShowGeneric(\n        string header,\n        string hint,\n        List<TargetEntry> targets,\n        int agentSlotsMin,\n        int agentSlotsMax,\n        Action<string, List<string>> onConfirm,\n        string modeLabel = \"Generic\")\n    {\n        ShowGenericInternal(header, hint, targets, agentSlotsMin, agentSlotsMax, onConfirm, modeLabel);\n    }\n\n    private void ShowGenericInternal(\n        string header,\n        string hint,\n        List<TargetEntry> targets,\n        int agentSlotsMin,\n        int agentSlotsMax,\n        Action<string, List<string>> onConfirm,\n        string modeLabel)\n    {\n        _mode = modeLabel == \"Manage\" ? AssignPanelMode.Manage : AssignPanelMode.Generic;\n        _onConfirm = onConfirm;\n        _slotsMin = agentSlotsMin;\n        _slotsMax = agentSlotsMax;\n\n        if (headerText) headerText.text = header ?? \"\";\n        if (hintText) hintText.text = hint ?? \"\";\n\n        var safeTargets = targets ?? new List<TargetEntry>();\n        if (string.IsNullOrEmpty(_selectedTargetId) || !safeTargets.Any(x => x != null && x.id == _selectedTargetId))\n            _selectedTargetId = safeTargets.FirstOrDefault()?.id;\n\n        RebuildTargetList(safeTargets);\n        RebuildAgentList();\n        RefreshConfirmState();\n\n        Debug.Log($\"[AssignPanel] mode={modeLabel} targets={safeTargets.Count} slots={_slotsMin}-{_slotsMax}\");\n    }\n\n    private void RebuildTargetList(List<TargetEntry> list)\n    {\n        // Clear\n        for (int i = 0; i < _anomalyItems.Count; i++)\n            if (_anomalyItems[i]) Destroy(_anomalyItems[i]);\n        _anomalyItems.Clear();\n        _currentTargets.Clear();\n\n        if (!anomalyListContent || !anomalyListItemPrefab)\n            return;\n\n        if (list == null || list.Count == 0) return;\n\n        foreach (var entry in list)\n        {\n            var go = Instantiate(anomalyListItemPrefab, anomalyListContent);\n            string entryId = entry?.id ?? \"\";\n            go.name = \"Target_\" + entryId;\n            _anomalyItems.Add(go);\n            _currentTargets.Add(entry);\n\n            SetListItemLabels(go, entry);\n\n            bool selected = (entryId == _selectedTargetId);\n            SetListItemSelectedVisual(go, selected);\n\n            var btn = go.GetComponentInChildren<Button>(true);\n            if (btn)\n            {\n                btn.onClick.RemoveAllListeners();\n                string id = entryId;\n                btn.interactable = entry == null || !entry.disabled;\n                btn.onClick.AddListener(() => SelectTarget(id));\n            }\n        }\n    }\n\n    private static string BuildAnomalyLabel(ManagedAnomalyState a, int mgr)\n    {\n        if (a == null) return \"\";\n        return $\"Lv{a.Level} {a.Name}  (管理:{mgr})\";\n    }\n\n    private void SetListItemSelectedVisual(GameObject go, bool selected)\n    {\n        // Minimal visual: try Image tint if present.\n        var img = go.GetComponentInChildren<Image>(true);\n        if (img)\n        {\n            img.color = selected ? new Color(0f, 0.68f, 0.71f, 0.25f) : new Color(1f, 1f, 1f, 0.05f);\n        }\n    }\n\n    private void SelectTarget(string targetId)\n    {\n        _selectedTargetId = targetId;\n        _selectedAgentIds.Clear();\n\n        Debug.Log($\"[AssignPanelSelect] targetId={_selectedTargetId}\");\n\n        if (_mode == AssignPanelMode.Manage)\n        {\n            // Pull current assignment (prefer Manage Task, fallback legacy field)\n            var gc = GameController.I;\n            var node = (gc != null && !string.IsNullOrEmpty(_nodeId)) ? gc.GetNode(_nodeId) : null;\n            var mt = FindManageTask(node, targetId);\n            if (mt?.AssignedAgentIds != null)\n            {\n                foreach (var id in mt.AssignedAgentIds)\n                    _selectedAgentIds.Add(id);\n            }\n        }\n\n        RebuildAgentList();\n        RefreshTargetSelectionVisuals();\n        UpdateHeader();\n    }\n\n    private void RebuildAgentList()\n    {\n        // Clear\n        for (int i = 0; i < _agentItems.Count; i++)\n            if (_agentItems[i]) Destroy(_agentItems[i].gameObject);\n        _agentItems.Clear();\n\n        if (!agentListContent || !agentPickerItemPrefab)\n            return;\n\n        var gc = GameController.I;\n        if (gc == null) return;\n\n        var node = !string.IsNullOrEmpty(_nodeId) ? gc.GetNode(_nodeId) : null;\n        if (_mode == AssignPanelMode.Manage)\n        {\n            var anomaly = FindManagedAnomaly(node, _selectedTargetId);\n            if (anomaly == null)\n                return;\n\n            // Sync selection from Manage Task (source of truth), fallback legacy.\n            var mt = FindManageTask(node, anomaly.Id);\n            _selectedAgentIds.Clear();\n            if (mt?.AssignedAgentIds != null)\n                foreach (var id in mt.AssignedAgentIds) _selectedAgentIds.Add(id);\n        }\n\n        foreach (var ag in gc.State.Agents)\n        {\n            if (ag == null) continue;\n\n            bool selected = _selectedAgentIds.Contains(ag.Id);\n\n            // Busy check (global): any active task (including Manage) OR legacy management occupancy.\n            bool busyTask = GameControllerTaskExt.AreAgentsBusy(gc, new List<string> { ag.Id });\n\n            // Allow clicking to deselect even if currently busy (soft lock)\n            bool isBusyOther = (!selected) && busyTask;\n\n            var go = Instantiate(agentPickerItemPrefab, agentListContent);\n            go.name = \"Agent_\" + ag.Id;\n\n            var item = go.GetComponent<AgentPickerItemView>();\n            if (item == null) item = go.AddComponent<AgentPickerItemView>();\n\n            item.Bind(\n                ag.Id,\n                ag.Name,\n                BuildAgentAttrLine(ag),\n                isBusyOther,\n                selected,\n                OnAgentClicked);\n\n            _agentItems.Add(item);\n        }\n\n        // Update confirm button\n        RefreshConfirmState();\n    }\n\n    private static string BuildAgentAttrLine(AgentState a)\n    {\n        if (a == null) return \"\";\n        return $\"P{a.Perception} O{a.Operation} R{a.Resistance} Pow{a.Power}\";\n    }\n\n    private void OnAgentClicked(string agentId)\n    {\n        if (string.IsNullOrEmpty(agentId)) return;\n\n        if (_selectedAgentIds.Contains(agentId))\n        {\n            _selectedAgentIds.Remove(agentId);\n        }\n        else\n        {\n            if (_selectedAgentIds.Count >= _slotsMax)\n            {\n                Debug.LogWarning($\"[TaskDef] manage slot selection exceeds max. slotsMax={_slotsMax}\");\n                return;\n            }\n            _selectedAgentIds.Add(agentId);\n        }\n\n        // Refresh only selection visuals\n        foreach (var it in _agentItems)\n        {\n            if (it == null) continue;\n            it.SetSelected(_selectedAgentIds.Contains(it.AgentId));\n        }\n\n        UpdateHeader();\n        RefreshConfirmState();\n    }\n\n    private void Confirm()\n    {\n        var gc = GameController.I;\n        if (gc == null) return;\n\n        if (_selectedAgentIds.Count < _slotsMin || _selectedAgentIds.Count > _slotsMax)\n        {\n            string message = $\"需要选择 {_slotsMin}-{_slotsMax} 名干员，目前为 {_selectedAgentIds.Count}。\";\n            if (hintText) hintText.text = message;\n            Debug.LogWarning($\"[TaskDef] manage slot selection invalid. count={_selectedAgentIds.Count} slotsMin={_slotsMin} slotsMax={_slotsMax}\");\n            return;\n        }\n\n        var targetId = _selectedTargetId ?? \"\";\n        var agentIds = _selectedAgentIds.ToList();\n\n        Debug.Log($\"[AssignPanelConfirm] targetId={targetId} agents={string.Join(\",\", agentIds)}\");"
        },
        {
            "id": 5,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: UI/UIPanelRoot\n// Source: Assets/Scripts/UI/UIPanelRoot.cs\n// Version: UI_UIPanelRoot_v2_20260114a\n// Updated for N-task backend:\n// - Each click on 调查/收容 creates a NEW task (NodeTask) and opens AgentPicker bound to that taskId.\n// - This enables multiple investigate tasks and multiple contain tasks (one per containable).\n// - On picker cancel (or close), the newly created task is cancelled to avoid leaving invisible active tasks.\n//\n// Notes:\n// - Busy check still uses GameControllerTaskExt.AreAgentsBusy (global task scan).\n// - Contain requires node.Containables.Count > 0; target selection picks a containable not already targeted by an active contain task when possible.\n// - UI still uses ConfirmDialog for info prompts.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Core;\nusing Data;\nusing UnityEngine;\n\npublic class UIPanelRoot : MonoBehaviour\n{\n    public static UIPanelRoot I { get; private set; }\n\n    [Header(\"Prefabs (请把 Assets/Prefabs/UI 下的文件拖进来)\")]\n    [SerializeField] private HUD hudPrefab; // HUD Prefab\n    [SerializeField] private NodePanelView nodePanelPrefab;\n    [SerializeField] private EventPanel eventPanelPrefab;\n    [SerializeField] private NewsPanel newsPanelPrefab;\n    [SerializeField] private AgentPickerView agentPickerPrefab;\n    [SerializeField] private ConfirmDialog confirmDialogPrefab;\n    [SerializeField] private GameObject managePanelPrefab; // 管理面板 Prefab（你新建的管理界面）\n    [SerializeField] private RecruitPanel recruitPanelPrefab;\n\n    // --- 运行时实例 (自动生成) ---\n    private HUD _hud;\n    private NodePanelView _nodePanel;\n    private EventPanel _eventPanel;\n    private NewsPanel _newsPanel;\n    private AgentPickerView _agentPicker;\n    private ConfirmDialog _confirmDialog;\n    private GameObject _managePanel;\n    private AnomalyManagePanel _managePanelView;\n    private RecruitPanel _recruitPanel;\n\n    private string _currentNodeId;\n    private string _manageNodeId; // 当前打开的管理面板所对应的节点（与 NodePanel 的当前节点解耦）\n    private string _pickerTaskId;\n    private bool _suppressAutoOpenEvent;\n\n    public string CurrentNodeId => _currentNodeId;\n    public string ManageNodeId => _manageNodeId;\n\n    private void Awake()\n    {\n        I = this;\n    }\n\n    private void Start()\n    {\n        InitHUD();\n    }\n\n    private void OnEnable()\n    {\n        if (GameController.I != null) GameController.I.OnStateChanged += OnGameStateChanged;\n    }\n\n    private void OnDisable()\n    {\n        if (GameController.I != null) GameController.I.OnStateChanged -= OnGameStateChanged;\n    }\n\n    void InitHUD()\n    {\n        if (_hud) return;\n        if (hudPrefab)\n        {\n            _hud = Instantiate(hudPrefab, transform);\n            // HUD should be at the bottom so panels can cover it\n            _hud.transform.SetAsFirstSibling();\n        }\n    }\n\n    void OnGameStateChanged()\n    {\n        // 1. If node panel is open, refresh it\n        if (_nodePanel != null && _nodePanel.gameObject.activeSelf)\n            _nodePanel.Refresh();\n\n        // 2. Try auto-open event\n        TryAutoOpenEvent();\n    }\n\n    // ================== NODE PANEL ==================\n\n    public void OpenNode(string nodeId)\n    {\n        _currentNodeId = nodeId;\n\n        EnsureNodePanel();\n        _nodePanel.Show(nodeId);\n    }\n\n    public void CloseNode()\n    {\n        ForceCancelPickerIfNeeded(true);\n        if (_nodePanel) _nodePanel.Hide();\n        _currentNodeId = null;\n        // 注意：不要清理 _manageNodeId。管理面板可能仍在打开，需要保持其上下文。\n    }\n\n    public void RefreshNodePanel() // 兼容旧接口\n    {\n        if (_nodePanel && _nodePanel.gameObject.activeSelf) _nodePanel.Refresh();\n    }\n\n    void EnsureNodePanel()\n    {\n        if (_nodePanel) return;\n        if (!nodePanelPrefab) { Debug.LogError(\"NodePanelPrefab 未配置！\"); return; }\n\n        _nodePanel = Instantiate(nodePanelPrefab, transform);\n        // Inject callbacks\n        _nodePanel.Init(\n            onInvestigate: () => OpenInvestigateAssignPanel(),\n            onContain: () => OpenContainAssignPanel(),\n            onClose: () => CloseNode()\n        );\n    }\n\n    // ================== CONFIRM DIALOG ==================\n\n    void EnsureConfirmDialog()\n    {\n        if (_confirmDialog) return;\n        if (!confirmDialogPrefab) return;\n        _confirmDialog = Instantiate(confirmDialogPrefab, transform);\n    }\n\n    void ShowInfo(string title, string message)\n    {\n        EnsureConfirmDialog();\n        if (_confirmDialog)\n        {\n            _confirmDialog.ShowInfo(title, message);\n            _confirmDialog.transform.SetAsLastSibling();\n        }\n        else\n        {\n            Debug.LogWarning($\"[UIPanelRoot] ConfirmDialog prefab not set. Info: {title} / {message}\");\n        }\n    }\n\n    // ================== ASSIGNMENT PANEL (Investigate / Contain) ==================\n\n    void OpenInvestigateAssignPanel()\n    {\n        if (GameController.I == null) return;\n        if (string.IsNullOrEmpty(_currentNodeId)) return;\n\n        EnsureManagePanel();\n        if (!_managePanelView) return;\n\n        var gc = GameController.I;\n        var node = gc.GetNode(_currentNodeId);\n        if (node == null)\n        {\n            ShowInfo(\"派遣失败\", \"节点不存在\");\n            return;\n        }\n\n        var registry = DataRegistry.Instance;\n        var targets = BuildInvestigateTargets(node, registry, gc.State?.NewsLog);\n        var (slotsMin, slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Investigate, 1, int.MaxValue);\n\n        _manageNodeId = _currentNodeId;\n        if (_managePanel) _managePanel.SetActive(true);\n        _managePanel.transform.SetAsLastSibling();\n        _managePanelView.ShowGeneric(\n            header: $\"Investigate | {_currentNodeId}\",\n            hint: \"选择新闻线索（可选）并派遣干员\",\n            targets: targets,\n            agentSlotsMin: slotsMin,\n            agentSlotsMax: slotsMax,\n            onConfirm: (targetId, agentIds) =>\n            {\n                if (agentIds == null || agentIds.Count == 0)\n                {\n                    ShowInfo(\"派遣失败\", \"未选择干员\");\n                    return;\n                }\n\n                if (GameControllerTaskExt.AreAgentsBusy(gc, agentIds, null))\n                {\n                    ShowInfo(\"派遣失败\", \"部分干员正在其他任务执行中\");\n                    return;\n                }\n\n                var task = gc.CreateInvestigateTask(_currentNodeId);\n                if (task == null)\n                {\n                    ShowInfo(\"派遣失败\", \"创建任务失败\");\n                    return;\n                }\n\n                string targetNewsId = string.IsNullOrEmpty(targetId) ? null : targetId;\n                task.TargetNewsId = targetNewsId;\n\n                string sourceAnomalyId = null;\n                if (!string.IsNullOrEmpty(targetNewsId))\n                {\n                    var news = gc.State?.NewsLog?.FirstOrDefault(n => n != null && n.Id == targetNewsId);\n                    sourceAnomalyId = news?.SourceAnomalyId;\n                    task.SourceAnomalyId = sourceAnomalyId;\n                    Debug.Log($\"[InvestigateBindNews] taskId={task.Id} newsId={targetNewsId} srcAnom={sourceAnomalyId} nodeId={_currentNodeId}\");\n                }\n\n                gc.AssignTask(task.Id, agentIds);\n                _managePanelView.Hide();\n                RefreshNodePanel();\n            },\n            modeLabel: \"Investigate\"\n        );\n    }\n\n    void OpenContainAssignPanel()\n    {\n        if (GameController.I == null) return;\n        if (string.IsNullOrEmpty(_currentNodeId)) return;\n\n        EnsureManagePanel();\n        if (!_managePanelView) return;\n\n        var gc = GameController.I;\n        var node = gc.GetNode(_currentNodeId);\n        if (node == null)\n        {\n            ShowInfo(\"派遣失败\", \"节点不存在\");\n            return;\n        }\n\n        if (node.ActiveAnomalyIds == null || node.ActiveAnomalyIds.Count == 0)\n        {\n            ShowInfo(\"派遣失败\", \"未发现可收容目标：该节点暂无异常\");\n            return;\n        }\n\n        var registry = DataRegistry.Instance;\n        var targets = BuildContainTargets(node, registry);\n        var (slotsMin, slotsMax) = registry.GetTaskAgentSlotRangeWithWarn(TaskType.Contain, 1, int.MaxValue);\n\n        _manageNodeId = _currentNodeId;\n        if (_managePanel) _managePanel.SetActive(true);\n        _managePanel.transform.SetAsLastSibling();\n        _managePanelView.ShowGeneric(\n            header: $\"Contain | {_currentNodeId}\",\n            hint: \"选择要收容的异常并派遣干员\",\n            targets: targets,\n            agentSlotsMin: slotsMin,\n            agentSlotsMax: slotsMax,\n            onConfirm: (targetAnomalyId, agentIds) =>\n            {\n                if (string.IsNullOrEmpty(targetAnomalyId))\n                {\n                    ShowInfo(\"派遣失败\", \"未选择收容目标\");\n                    return;\n                }\n\n                if (agentIds == null || agentIds.Count == 0)\n                {\n                    ShowInfo(\"派遣失败\", \"未选择干员\");\n                    return;\n                }\n\n                if (GameControllerTaskExt.AreAgentsBusy(gc, agentIds, null))\n                {\n                    ShowInfo(\"派遣失败\", \"部分干员正在其他任务执行中\");\n                    return;\n                }\n\n                string containableId = EnsureContainableForAnomaly(node, registry, targetAnomalyId);\n                var task = gc.CreateContainTask(_currentNodeId, containableId);\n                if (task == null)\n                {\n                    ShowInfo(\"派遣失败\", \"创建任务失败\");\n                    return;\n                }\n\n                task.SourceAnomalyId = targetAnomalyId;\n                gc.AssignTask(task.Id, agentIds);\n                _managePanelView.Hide();\n                RefreshNodePanel();\n            },\n            modeLabel: \"Contain\"\n        );\n    }\n\n    private List<AnomalyManagePanel.TargetEntry> BuildInvestigateTargets(NodeState node, DataRegistry registry, List<NewsInstance> newsLog)\n    {\n        var targets = new List<AnomalyManagePanel.TargetEntry>\n        {\n            new AnomalyManagePanel.TargetEntry\n            {\n                id = \"\",\n                title = \"随意调查\",\n                subtitle = \"不针对任何新闻（较慢）\",\n                disabled = false\n            }\n        };\n\n        if (newsLog == null) return targets;\n\n        foreach (var news in newsLog)\n        {\n            if (news == null) continue;\n            if (!string.Equals(news.NodeId, node.Id, StringComparison.OrdinalIgnoreCase)) continue;\n            if (news.IsResolved) continue;\n\n            var def = registry.GetNewsDefById(news.NewsDefId);\n            string title = def?.title ?? news.NewsDefId ?? \"\";\n            string subtitle = !string.IsNullOrEmpty(news.SourceAnomalyId)\n                ? $\"线索指向：{news.SourceAnomalyId}\"\n                : \"线索来源未知\";\n\n            targets.Add(new AnomalyManagePanel.TargetEntry\n            {\n                id = news.Id,\n                title = title,\n                subtitle = subtitle,\n                disabled = false\n            });\n        }\n\n        return targets;\n    }\n\n    private List<AnomalyManagePanel.TargetEntry> BuildContainTargets(NodeState node, DataRegistry registry)\n    {\n        var targets = new List<AnomalyManagePanel.TargetEntry>();\n        if (node.ActiveAnomalyIds == null) return targets;\n\n        foreach (var anomalyId in node.ActiveAnomalyIds)\n        {\n            if (string.IsNullOrEmpty(anomalyId)) continue;\n            var def = registry.AnomaliesById.TryGetValue(anomalyId, out var anomalyDef) ? anomalyDef : null;\n            string title = def?.name ?? anomalyId;\n\n            targets.Add(new AnomalyManagePanel.TargetEntry\n            {\n                id = anomalyId,\n                title = title,\n                subtitle = null,\n                disabled = false\n            });\n        }\n\n        return targets;\n    }\n\n    private string EnsureContainableForAnomaly(NodeState node, DataRegistry registry, string anomalyId)\n    {\n        if (node == null || string.IsNullOrEmpty(anomalyId)) return null;\n        if (node.Containables == null) node.Containables = new List<ContainableItem>();\n\n        var existing = node.Containables.FirstOrDefault(c => c != null && c.AnomalyId == anomalyId);\n        if (existing != null) return existing.Id;\n\n        var def = registry.AnomaliesById.TryGetValue(anomalyId, out var anomalyDef) ? anomalyDef : null;\n        int level = def != null ? Math.Max(1, def.baseThreat) : Math.Max(1, node.AnomalyLevel);\n        var item = new ContainableItem\n        {\n            Id = $\"SCP_{node.Id}_{Guid.NewGuid().ToString(\"N\")[..6]}\",\n            Name = def != null ? $\"{def.name} 线索（{node.Name}）\" : $\"未编号异常（{node.Name}）\",\n            Level = level,\n            AnomalyId = anomalyId,\n        };\n        node.Containables.Add(item);\n        return item.Id;\n    }\n\n    // ================== MANAGE PANEL ==================\n\n    void EnsureManagePanel()\n    {\n        if (_managePanel) return;\n        if (!managePanelPrefab)\n        {\n            Debug.LogWarning(\"[UIPanelRoot] managePanelPrefab 未配置！\");\n            return;\n        }\n        _managePanel = Instantiate(managePanelPrefab, transform);\n        _managePanelView = _managePanel.GetComponent<AnomalyManagePanel>();\n        _managePanel.SetActive(false);\n    }\n\n    // 由 NodePanel 的“管理”按钮调用（推荐：传入当前节点 id）\n    public void OpenManage(string nodeId)\n    {"
        }
    ]
}