{
    "batch_id": "B1_export_sim_news_discover",
    "results": [
        {
            "id": 1,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Core/Sim (v4 - data driven events)\n// Source: Assets/Scripts/Core/Sim.cs\n// Goal: Load all game data from DataRegistry and drive events/effects via config.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Data;\nusing UnityEngine;\nusing Random = System.Random;\n\nnamespace Core\n{\n    public static class Sim\n    {\n        // Agent Level/Exp helpers\n        public static int ExpToNext(int level)\n        {\n            return 20 + (level - 1) * 10;\n        }\n\n        // Returns true if level up occurred\n        public static bool AddExpAndTryLevelUp(Core.AgentState a, int addExp, System.Random rng)\n        {\n            if (addExp > 0)\n            {\n                Debug.Log($\"[AgentLevel] agent={a.Id} lv={a.Level} exp={a.Exp}->{a.Exp + addExp}\");\n            }\n            a.Exp += addExp;\n            bool leveled = false;\n            while (a.Exp >= ExpToNext(a.Level))\n            {\n                int oldLv = a.Level;\n                a.Exp -= ExpToNext(a.Level);\n                a.Level += 1;\n                a.TalentPoints += 1;\n                int grow = rng.Next(0, 4);\n                string growStr = \"\";\n                switch (grow)\n                {\n                    case 0:\n                        a.Perception += 1;\n                        growStr = \"Perception+1\";\n                        break;\n                    case 1:\n                        a.Resistance += 1;\n                        growStr = \"Resistance+1\";\n                        break;\n                    case 2:\n                        a.Operation += 1;\n                        growStr = \"Operation+1\";\n                        break;\n                    case 3:\n                        a.Power += 1;\n                        growStr = \"Power+1\";\n                        break;\n                }\n                Debug.Log($\"[AgentLevel] agent={a.Id} lv={oldLv}->{a.Level} exp={a.Exp} tp={a.TalentPoints} grow={growStr}\");\n                leveled = true;\n            }\n            return leveled;\n        }\n\n        private const string RequirementAny = \"ANY\";\n        private const string RandomDailySource = \"RandomDaily\";\n\n        public static event Action OnIgnorePenaltyApplied;\n\n        private static readonly HashSet<TaskType> WarnedMissingYieldFields = new();\n        private static readonly HashSet<TaskType> WarnedUnknownYieldKey = new();\n        private static readonly HashSet<string> WarnedDifficultyAnomalies = new();\n\n        public static void StepDay(GameState s, Random rng)\n        {\n            var registry = DataRegistry.Instance;\n\n            s.Day += 1;\n            if (s.RecruitPool != null)\n            {\n                s.RecruitPool.day = -1;\n                s.RecruitPool.refreshUsedToday = 0;\n                s.RecruitPool.candidates?.Clear();\n            }\n            s.News.Add($\"Day {s.Day}: 日结算开始\");\n\n            // 0) 异常生成（节点维度）\n            foreach (var n in s.Nodes)\n            {\n                if (n == null) continue;\n                if (n.Status == NodeStatus.Calm && !n.HasAnomaly)\n                {\n                    if (rng.NextDouble() < 0.15)\n                    {\n                        var anomalyId = PickRandomAnomalyId(registry, rng);\n                        if (!string.IsNullOrEmpty(anomalyId))\n                        {\n                            EnsureActiveAnomaly(n, anomalyId, registry);\n                            s.News.Add($\"- {n.Name} 出现异常迹象：{anomalyId}\");\n                        }\n                    }\n                }\n            }\n\n            // 1) 推进任务（任务维度：同节点可并行 N 个任务）\n            foreach (var n in s.Nodes)\n            {\n                if (n?.Tasks == null || n.Tasks.Count == 0) continue;\n\n                // 推进所有 Active 任务（按事件阻塞策略判断）\n                for (int i = 0; i < n.Tasks.Count; i++)\n                {\n                    var t = n.Tasks[i];\n                    if (t == null) continue;\n                    if (t.State != TaskState.Active) continue;\n                    if (t.AssignedAgentIds == null || t.AssignedAgentIds.Count == 0) continue;\n\n                    if (IsTaskBlockedByEvents(s, n, t, registry))\n                        continue;\n\n                    var squad = GetAssignedAgents(s, t.AssignedAgentIds);\n                    if (squad.Count == 0) continue;\n\n                    float baseDelta = CalcDailyProgressDelta(t, squad, rng, registry);\n                    string anomalyId = GetTaskAnomalyId(n, t);\n                    int diff = 1;\n                    if (t.Type == TaskType.Investigate || t.Type == TaskType.Contain)\n                    {\n                        diff = GetTaskDifficulty(anomalyId, t.Type, registry);\n                    }\n\n                    float effDelta = baseDelta / Math.Max(1, diff);\n                    int manageRisk = (t.Type == TaskType.Manage) ? GetManageRisk(anomalyId, registry) : 0;\n\n                    // Manage tasks are LONG-RUNNING: progress is only used as a \"started\" flag (0 vs >0).\n                    // They should never auto-complete.\n                    if (t.Type == TaskType.Manage)\n                    {\n                        float beforeManage = t.Progress;\n                        t.Progress = Math.Max(t.Progress, 0f);\n                        t.Progress = Clamp01(t.Progress + effDelta);\n                        if (t.Progress >= 1f) t.Progress = 0.99f;\n                        if (Math.Abs(t.Progress - beforeManage) > 0.0001f)\n                        {\n                            Debug.Log($\"[TaskProgress] day={s.Day} taskId={t.Id} type={t.Type} anomalyId={anomalyId} diff={diff} baseDelta={baseDelta:0.00} effDelta={effDelta:0.00} risk={manageRisk} progress={t.Progress:0.00}/1 (baseDays=1)\");\n                        }\n\n                        var defId = t.SourceAnomalyId;\n                        if (string.IsNullOrEmpty(defId))\n                        {\n                            Debug.LogWarning($\"[ManageDailySkip] day={s.Day} taskId={t.Id} node={n.Id} reason=MissingSourceAnomalyId target={t.TargetManagedAnomalyId ?? \"none\"}\");\n                            continue;\n                        }\n\n                        if (!registry.AnomaliesById.TryGetValue(defId, out var manageDef) || manageDef == null)\n                        {\n                            Debug.LogWarning($\"[ManageDailySkip] day={s.Day} taskId={t.Id} node={n.Id} reason=UnknownAnomalyDef target={t.TargetManagedAnomalyId ?? \"none\"} anomaly={defId}\");\n                            continue;\n                        }\n                        var impact = ComputeImpact(s, TaskType.Manage, manageDef, t.AssignedAgentIds);\n                        var req = NormalizeIntArray4(manageDef?.manReq);\n                        float magSan = (manageDef?.sanDmg ?? 0) * impact.sanMul * impact.S * impact.sanRand;\n                        Debug.Log(\n                            $\"[ImpactCalc] day={s.Day} type=Manage node={n.Id} anomaly={defId ?? \"unknown\"} base=({manageDef?.hpDmg ?? 0},{manageDef?.sanDmg ?? 0}) \" +\n                            $\"mul=({impact.hpMul:0.###},{impact.sanMul:0.###}) rand=({impact.hpRand:0.###},{impact.sanRand:0.###}) \" +\n                            $\"req={FormatIntArray(req)} team={FormatIntArray(impact.team)} D={impact.D:0.###} S={impact.S:0.###} magSan={magSan:0.###} final=({impact.hpDelta},{impact.sanDelta})\");\n                        foreach (var agentId in t.AssignedAgentIds)\n                        {\n                            string reason = $\"ManageDaily:node={n.Id},anomaly={defId ?? \"unknown\"},dayTick={s.Day}\";\n                            ApplyAgentImpact(s, agentId, 0, impact.sanDelta, reason);\n                        }\n                        continue;\n                    }\n\n                    int baseDays = Math.Max(1, registry.GetTaskBaseDaysWithWarn(t.Type, 1));\n                    float before = t.Progress;\n                    t.Progress = Mathf.Clamp(t.Progress + effDelta, 0f, baseDays);\n                    if (Math.Abs(t.Progress - before) > 0.0001f)\n                    {\n                        Debug.Log($\"[TaskProgress] day={s.Day} taskId={t.Id} type={t.Type} anomalyId={anomalyId} diff={diff} baseDelta={baseDelta:0.00} effDelta={effDelta:0.00} progress={t.Progress:0.00}/{baseDays} (baseDays={baseDays})\");\n                    }\n\n                    if (t.Progress >= baseDays)\n                    {\n                        CompleteTask(s, n, t, rng, registry);\n                    }\n                }\n            }\n\n            // 1.5) 收容后管理（负熵产出）\n            StepManageTasks(s, rng, registry);\n\n            // 1.75) 任务日结算产出（TaskDefs.yieldKey / yieldPerDay）\n            StepTaskDailyYield(s, registry);\n\n            // 2) 不处理的后果（按 IgnoreApplyMode 执行）\n            ApplyIgnorePenaltyOnDayEnd(s, registry);\n\n            // 2.5) 事件自动关闭（按 autoResolveAfterDays）\n            AutoResolvePendingEventsOnDayEnd(s, registry);\n\n            // 3) RandomDaily 事件生成\n            GenerateRandomDailyEvents(s, rng, registry);\n\n            // 3.5) RandomDaily 新闻生成\n            GenerateRandomDailyNews(s, rng, registry);\n\n            // 4) 经济 & 世界恐慌（全局）\n            float popToMoneyRate = registry.GetBalanceFloatWithWarn(\"PopToMoneyRate\", 0f);\n            int wagePerAgentPerDay = registry.GetBalanceIntWithWarn(\"WagePerAgentPerDay\", 0);\n            int maintenanceDefault = registry.GetBalanceIntWithWarn(\"ContainedAnomalyMaintenanceDefault\", 0);\n            int clampMoneyMin = registry.GetBalanceIntWithWarn(\"ClampMoneyMin\", 0);\n            float clampWorldPanicMin = registry.GetBalanceFloatWithWarn(\"ClampWorldPanicMin\", 0f);\n\n            int moneyBefore = s.Money;\n            int income = 0;\n            int maintenance = 0;\n            int safeNodeCount = 0;\n            float worldPanicAdd = 0f;\n\n            foreach (var node in s.Nodes)\n            {\n                if (node == null) continue;\n\n                income += Mathf.FloorToInt(node.Population * popToMoneyRate);\n\n                // Safe node definition (current): no uncontained anomalies on this node.\n                bool hasUncontained = node.Status != NodeStatus.Secured && node.ActiveAnomalyIds != null && node.ActiveAnomalyIds.Count > 0;\n                if (!hasUncontained) safeNodeCount++;\n\n                if (hasUncontained)\n                {\n                    foreach (var anomalyId in node.ActiveAnomalyIds)\n                    {\n                        if (string.IsNullOrEmpty(anomalyId))\n                        {\n                            Debug.LogWarning(\"[WARN] Missing anomalyId for world panic calculation. Using fallback=0.\");\n                            continue;\n                        }\n                        worldPanicAdd += registry.GetAnomalyFloatWithWarn(anomalyId, \"worldPanicPerDayUncontained\", 0f);\n                    }\n                }\n\n                if (node.ManagedAnomalies == null) continue;\n                foreach (var managed in node.ManagedAnomalies)\n                {\n                    if (managed == null) continue;\n                    if (string.IsNullOrEmpty(managed.AnomalyId))\n                    {\n                        Debug.LogWarning($\"[WARN] Managed anomaly {managed.Id} missing anomalyId. Using default maintenance={maintenanceDefault}.\");\n                        maintenance += maintenanceDefault;\n                        continue;\n                    }\n                    maintenance += registry.GetAnomalyIntWithWarn(managed.AnomalyId, \"maintenanceCostPerDay\", maintenanceDefault);\n                }\n            }\n\n            int wage = (s.Agents?.Count ?? 0) * wagePerAgentPerDay;\n            int optionCost = 0; // TODO: hook event option costs if/when EffectOps expose them.\n            int moneyAfter = moneyBefore + income - wage - maintenance - optionCost;"
        },
        {
            "id": 2,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "            if (moneyAfter < clampMoneyMin) moneyAfter = clampMoneyMin;\n            s.Money = moneyAfter;\n\n            Debug.Log($\"[Economy] day={s.Day} income={income} wage={wage} maint={maintenance} option={optionCost} moneyBefore={moneyBefore} moneyAfter={moneyAfter}\");\n\n            float dailyDecay = registry.GetBalanceFloatWithWarn(\"DailyWorldPanicDecay\", 0f);\n            float decayPerSafeNode = registry.GetBalanceFloatWithWarn(\"WorldPanicDecayPerSafeNodePerDay\", 0f);\n            float worldPanicDecay = dailyDecay + safeNodeCount * decayPerSafeNode;\n            float worldPanicBefore = s.WorldPanic;\n            float worldPanicAfter = worldPanicBefore + worldPanicAdd - worldPanicDecay;\n            if (worldPanicAfter < clampWorldPanicMin) worldPanicAfter = clampWorldPanicMin;\n            s.WorldPanic = worldPanicAfter;\n\n            float failThreshold = registry.GetBalanceFloatWithWarn(\"WorldPanicFailThreshold\", 0f);\n            Debug.Log($\"[WorldPanic] day={s.Day} add={worldPanicAdd:0.##} decay={worldPanicDecay:0.##} safe={safeNodeCount} before={worldPanicBefore:0.##} after={worldPanicAfter:0.##} threshold={failThreshold:0.##}\");\n\n            if (s.WorldPanic >= failThreshold && GameController.I != null)\n            {\n                GameController.I.MarkGameOver($\"reason=WorldPanic day={s.Day} value={s.WorldPanic:0.##} threshold={failThreshold:0.##}\");\n            }\n\n            s.News.Add($\"Day {s.Day} 结束\");\n        }\n\n        public static (bool success, string text) ResolveEvent(GameState s, string nodeId, string eventInstanceId, string optionId, Random rng)\n        {\n            var registry = DataRegistry.Instance;\n            var node = s.Nodes.FirstOrDefault(n => n != null && n.Id == nodeId);\n            if (node == null) return (false, \"节点不存在\");\n            if (node.PendingEvents == null || node.PendingEvents.Count == 0) return (false, \"节点无事件\");\n\n            var ev = node.PendingEvents.FirstOrDefault(e => e != null && e.EventInstanceId == eventInstanceId);\n            if (ev == null) return (false, \"事件不存在\");\n            if (!registry.TryGetEvent(ev.EventDefId, out var eventDef)) return (false, \"事件配置不存在\");\n            if (!registry.TryGetOption(ev.EventDefId, optionId, out var optionDef)) return (false, \"选项不存在\");\n\n            var originTask = TryGetOriginTask(s, ev.SourceTaskId, out var originNode) ? originNode?.Tasks?.FirstOrDefault(t => t != null && t.Id == ev.SourceTaskId) : null;\n\n            var affects = ResolveAffects(eventDef, optionDef, registry);\n            var ctx = new EffectContext\n            {\n                State = s,\n                Node = node,\n                OriginTask = originTask,\n                EventDefId = ev.EventDefId,\n                OptionId = optionId,\n            };\n            int effectsApplied = EffectOpExecutor.ApplyEffect(optionDef.effectId, ctx, affects);\n\n            node.PendingEvents.Remove(ev);\n\n            Debug.Log($\"[EventResolve] node={node.Id} inst={ev.EventInstanceId} def={ev.EventDefId} option={optionDef.optionId} effectsApplied={effectsApplied}\");\n\n            // ===== HP/SAN Impact for Events (hardcoded examples) =====\n            // Apply impacts to agents assigned to the origin task, if any\n            if (originTask != null && originTask.AssignedAgentIds != null && originTask.AssignedAgentIds.Count > 0)\n            {\n                int hpDelta = 0;\n                int sanDelta = 0;\n\n                // Hardcoded examples for specific events\n                if (ev.EventDefId == \"EV_001\") // Example event 1\n                {\n                    hpDelta = -(1 + rng.Next(3)); // -1 to -3\n                    sanDelta = -(2 + rng.Next(3)); // -2 to -4\n                }\n                else if (ev.EventDefId == \"EV_002\") // Example event 2\n                {\n                    hpDelta = -(2 + rng.Next(4)); // -2 to -5\n                    sanDelta = -(1 + rng.Next(2)); // -1 to -2\n                }\n                else if (ev.EventDefId == \"EV_003\") // Example event 3\n                {\n                    hpDelta = 0;\n                    sanDelta = -(3 + rng.Next(3)); // -3 to -5\n                }\n\n                // Apply to all agents on the task if any delta was set\n                if (hpDelta != 0 || sanDelta != 0)\n                {\n                    foreach (var agentId in originTask.AssignedAgentIds)\n                    {\n                        string reason = $\"EventResolve:event={ev.EventDefId},option={optionId},node={node.Id}\";\n                        ApplyAgentImpact(s, agentId, hpDelta, sanDelta, reason);\n                    }\n                }\n            }\n\n            s.News.Add($\"- {node.Name} 事件处理：{eventDef.title} -> {optionDef.text}\");\n\n            var resultText = string.IsNullOrEmpty(optionDef.resultText) ? BuildEffectSummary(optionDef.effectId, affects) : optionDef.resultText;\n            if (string.IsNullOrEmpty(resultText)) resultText = optionDef.text;\n            if (string.IsNullOrEmpty(resultText)) resultText = \"事件已处理\";\n            return (true, resultText);\n        }\n\n        private static void GenerateRandomDailyEvents(GameState s, Random rng, DataRegistry registry)\n        {\n            if (s == null || s.Nodes == null) return;\n\n            var randomDailyDefs = registry.EventsById.Values\n                .Where(def => def != null &&\n                              !string.IsNullOrEmpty(def.eventDefId) &&\n                              string.Equals(def.source, RandomDailySource, StringComparison.OrdinalIgnoreCase))\n                .ToList();\n\n            int taskCtxChecked = 0;\n            int taskFired = 0;\n            int nodeCtxChecked = 0;\n            int nodeFired = 0;\n\n            var firedCounts = s.EventFiredCounts ??= new Dictionary<string, int>();\n            var lastFiredDay = s.EventLastFiredDay ??= new Dictionary<string, int>();\n\n            foreach (var node in s.Nodes)\n            {\n                if (node?.Tasks == null || node.Tasks.Count == 0) continue;\n\n                foreach (var task in node.Tasks)\n                {\n                    if (task == null || task.State != TaskState.Active) continue;\n                    if (task.Type != TaskType.Investigate && task.Type != TaskType.Contain && task.Type != TaskType.Manage) continue;\n\n                    taskCtxChecked += 1;\n                    int pendingBefore = node.PendingEvents?.Count ?? 0;\n                    string ctxTaskTypeKey = GetTaskTypeKey(task.Type);\n                    string ctxAnomalyId = GetTaskAnomalyId(node, task);\n\n                    if (pendingBefore > 0)\n                    {\n                        Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll=0 p=0 allow=false reason=pendingEvents pendingBefore={pendingBefore}\");\n                        continue;\n                    }\n\n                    var matched = GetRandomDailyMatches(randomDailyDefs, s.Day, node.Id, ctxTaskTypeKey, ctxAnomalyId, firedCounts, lastFiredDay, requireAnomalyAny: false);\n                    Debug.Log($\"[EventPool] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} candidates={randomDailyDefs.Count} matched={matched.Count}\");\n\n                    if (matched.Count == 0)\n                    {\n                        Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll=0 p=0 allow=false reason=noMatch pendingBefore={pendingBefore}\");\n                        continue;\n                    }\n\n                    float pContext = Mathf.Clamp01(matched.Max(def => def.p));\n                    double roll = rng.NextDouble();\n                    bool allow = roll <= pContext;\n                    string reason = allow ? \"trigger\" : \"rollTooHigh\";\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Task node={node.Id} taskId={task.Id} taskType={ctxTaskTypeKey} anomaly={ctxAnomalyId ?? \"none\"} roll={roll:0.00} p={pContext:0.00} allow={allow} reason={reason} pendingBefore={pendingBefore}\");\n\n                    if (!allow) continue;\n                    if (!TryPickWeighted(matched, rng, out var picked)) continue;\n\n                    var instance = EventInstanceFactory.Create(picked.eventDefId, node.Id, s.Day, task.Id, ctxAnomalyId, RandomDailySource);\n                    AddEventToNode(node, instance);\n                    UpdateEventFireTracking(s.Day, picked.eventDefId, firedCounts, lastFiredDay);\n                    taskFired += 1;\n\n                    Debug.Log($\"[EventGen] day={s.Day} ctx=Task node={node.Id} eventDefId={picked.eventDefId} inst={instance.EventInstanceId} cause={RandomDailySource} taskId={task.Id} anomalyId={ctxAnomalyId ?? \"none\"}\");\n                    s.News.Add($\"- {node.Name} 发生事件：{picked.title}\");\n                }\n            }\n\n            foreach (var node in s.Nodes)\n            {\n                if (node == null) continue;\n                nodeCtxChecked += 1;\n\n                int pendingBefore = node.PendingEvents?.Count ?? 0;\n                if (pendingBefore > 0)\n                {\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll=0 p=0 allow=false reason=pendingEvents pendingBefore={pendingBefore}\");\n                    continue;\n                }\n\n                var matched = GetRandomDailyMatches(randomDailyDefs, s.Day, node.Id, RequirementAny, null, firedCounts, lastFiredDay, requireAnomalyAny: true);\n                Debug.Log($\"[EventPool] day={s.Day} ctx=Node node={node.Id} taskId=none candidates={randomDailyDefs.Count} matched={matched.Count}\");\n\n                if (matched.Count == 0)\n                {\n                    Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll=0 p=0 allow=false reason=noMatch pendingBefore={pendingBefore}\");\n                    continue;\n                }\n\n                float pContext = Mathf.Clamp01(matched.Max(def => def.p));\n                double roll = rng.NextDouble();\n                bool allow = roll <= pContext;\n                string reason = allow ? \"trigger\" : \"rollTooHigh\";\n                Debug.Log($\"[EventGenCheck] day={s.Day} ctx=Node node={node.Id} taskId=none taskType=ANY anomaly=none roll={roll:0.00} p={pContext:0.00} allow={allow} reason={reason} pendingBefore={pendingBefore}\");\n\n                if (!allow) continue;\n                if (!TryPickWeighted(matched, rng, out var picked)) continue;\n\n                var instance = EventInstanceFactory.Create(picked.eventDefId, node.Id, s.Day, null, null, RandomDailySource);\n                AddEventToNode(node, instance);\n                UpdateEventFireTracking(s.Day, picked.eventDefId, firedCounts, lastFiredDay);\n                nodeFired += 1;\n\n                Debug.Log($\"[EventGen] day={s.Day} ctx=Node node={node.Id} eventDefId={picked.eventDefId} inst={instance.EventInstanceId} cause={RandomDailySource} taskId=none anomalyId=none\");\n                s.News.Add($\"- {node.Name} 发生事件：{picked.title}\");\n            }\n\n            Debug.Log($\"[RandomDailySummary] day={s.Day} taskCtxChecked={taskCtxChecked} taskFired={taskFired} nodeCtxChecked={nodeCtxChecked} nodeFired={nodeFired}\");\n        }\n\n        private static void GenerateRandomDailyNews(GameState s, Random rng, DataRegistry registry)\n        {\n            if (s == null || s.Nodes == null) return;\n\n            var randomDailyDefs = registry.NewsDefsById.Values\n                .Where(def => def != null &&\n                              !string.IsNullOrEmpty(def.newsDefId) &&\n                              string.Equals(def.source, RandomDailySource, StringComparison.OrdinalIgnoreCase))\n                .ToList();\n\n            int nodeAnomCtxChecked = 0;\n            int nodeAnomPicked = 0;\n            int nodeAnomEmitted = 0;\n            int nodeCtxChecked = 0;\n            int nodePicked = 0;\n            int nodeEmitted = 0;\n\n            var firedCounts = s.NewsFiredCounts ??= new Dictionary<string, int>();\n            var lastFiredDay = s.NewsLastFiredDay ??= new Dictionary<string, int>();\n\n            foreach (var node in s.Nodes)\n            {\n                if (node?.ActiveAnomalyIds == null || node.ActiveAnomalyIds.Count == 0) continue;\n\n                foreach (var anomalyId in node.ActiveAnomalyIds)\n                {\n                    if (string.IsNullOrEmpty(anomalyId)) continue;\n                    nodeAnomCtxChecked += 1;\n\n                    var matched = GetRandomDailyNewsMatches(randomDailyDefs, s.Day, node.Id, anomalyId, firedCounts, lastFiredDay, requireAnomalyAny: false);\n                    if (matched.Count == 0) continue;\n\n                    if (!TryPickWeightedNews(matched, rng, out var picked)) continue;\n                    nodeAnomPicked += 1;\n\n                    double roll = rng.NextDouble();\n                    bool emit = roll <= picked.p;\n                    string reason = emit ? \"Picked\" : \"RolledAboveP\";\n                    Debug.Log($\"[NewsPick] day={s.Day} ctx=NodeAnom nodeId={node.Id} anomalyId={anomalyId} newsDefId={picked.newsDefId} weight={picked.weight} p={picked.p:0.00} roll={roll:0.00} emit={(emit ? 1 : 0)} reason={reason}\");\n                    if (!emit) continue;\n\n                    string sourceAnomalyId = IsRequirementAny(picked.requiresAnomalyId) ? null : anomalyId;\n                    var instance = NewsInstanceFactory.Create(picked.newsDefId, node.Id, sourceAnomalyId, RandomDailySource);\n                    AddNewsToLog(s, instance);\n                    UpdateNewsFireTracking(s.Day, picked.newsDefId, firedCounts, lastFiredDay);\n                    nodeAnomEmitted += 1;\n\n                    Debug.Log($\"[NewsGen] day={s.Day} ctx=NodeAnom nodeId={node.Id} anomalyId={anomalyId} newsDefId={picked.newsDefId} instId={instance.Id} cause={RandomDailySource}\");\n                }\n            }\n\n            foreach (var node in s.Nodes)\n            {\n                if (node == null) continue;\n                nodeCtxChecked += 1;\n\n                var matched = GetRandomDailyNewsMatches(randomDailyDefs, s.Day, node.Id, null, firedCounts, lastFiredDay, requireAnomalyAny: true);\n                if (matched.Count == 0) continue;\n\n                if (!TryPickWeightedNews(matched, rng, out var picked)) continue;\n                nodePicked += 1;\n\n                double roll = rng.NextDouble();\n                bool emit = roll <= picked.p;\n                string reason = emit ? \"Picked\" : \"RolledAboveP\";\n                Debug.Log($\"[NewsPick] day={s.Day} ctx=Node nodeId={node.Id} anomalyId=none newsDefId={picked.newsDefId} weight={picked.weight} p={picked.p:0.00} roll={roll:0.00} emit={(emit ? 1 : 0)} reason={reason}\");\n                if (!emit) continue;\n\n                var instance = NewsInstanceFactory.Create(picked.newsDefId, node.Id, null, RandomDailySource);\n                AddNewsToLog(s, instance);\n                UpdateNewsFireTracking(s.Day, picked.newsDefId, firedCounts, lastFiredDay);\n                nodeEmitted += 1;\n\n                Debug.Log($\"[NewsGen] day={s.Day} ctx=Node nodeId={node.Id} anomalyId=none newsDefId={picked.newsDefId} instId={instance.Id} cause={RandomDailySource}\");\n            }\n\n            Debug.Log($\"[RandomDailyNewsSummary] day={s.Day} nodeAnomCtxChecked={nodeAnomCtxChecked} nodeAnomPicked={nodeAnomPicked} nodeAnomEmitted={nodeAnomEmitted} nodeCtxChecked={nodeCtxChecked} nodePicked={nodePicked} nodeEmitted={nodeEmitted} newsTotal={(s.NewsLog?.Count ?? 0)}\");\n        }\n\n        public static bool ApplyIgnorePenaltyOnDayEnd(GameState s, DataRegistry registry)\n        {\n            bool anyApplied = false;\n            foreach (var node in s.Nodes)\n            {\n                if (node?.PendingEvents == null || node.PendingEvents.Count == 0) continue;\n\n                var toRemove = new List<EventInstance>();\n                foreach (var ev in node.PendingEvents)\n                {\n                    if (ev == null) continue;\n                    if (!registry.TryGetEvent(ev.EventDefId, out var def)) continue;\n\n                    var ignoreMode = registry.GetIgnoreApplyMode(def);\n                    if (ignoreMode == IgnoreApplyMode.NeverAuto) continue;\n                    if (string.IsNullOrEmpty(def.ignoreEffectId)) continue;\n"
        },
        {
            "id": 3,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "                    var originTask = TryGetOriginTask(s, ev.SourceTaskId, out var originNode)\n                        ? originNode?.Tasks?.FirstOrDefault(t => t != null && t.Id == ev.SourceTaskId)\n                        : null;\n\n                    var affects = GetDefaultAffects(def);\n                    var ctx = new EffectContext\n                    {\n                        State = s,\n                        Node = node,\n                        OriginTask = originTask,\n                        EventDefId = ev.EventDefId,\n                        OptionId = \"__ignore__\",\n                    };\n\n                    if (ignoreMode == IgnoreApplyMode.ApplyOnceThenRemove)\n                    {\n                        if (ev.IgnoreAppliedOnce) continue;\n                        EffectOpExecutor.ApplyEffect(def.ignoreEffectId, ctx, affects);\n                        ev.IgnoreAppliedOnce = true;\n                        toRemove.Add(ev);\n                        anyApplied = true;\n                        Debug.Log($\"[EventIgnore] day={s.Day} node={node.Id} eventInstanceId={ev.EventInstanceId} mode={ignoreMode} removed=true\");\n                    }\n                    else if (ignoreMode == IgnoreApplyMode.ApplyDailyKeep)\n                    {\n                        EffectOpExecutor.ApplyEffect(def.ignoreEffectId, ctx, affects);\n                        anyApplied = true;\n                        Debug.Log($\"[EventIgnore] day={s.Day} node={node.Id} eventInstanceId={ev.EventInstanceId} mode={ignoreMode} removed=false\");\n                    }\n                }\n\n                if (toRemove.Count > 0)\n                {\n                    foreach (var ev in toRemove) node.PendingEvents.Remove(ev);\n                }\n            }\n\n            if (anyApplied) OnIgnorePenaltyApplied?.Invoke();\n            return anyApplied;\n        }\n\n        private static void AutoResolvePendingEventsOnDayEnd(GameState s, DataRegistry registry)\n        {\n            int scanned = 0;\n            int removed = 0;\n\n            foreach (var node in s.Nodes)\n            {\n                if (node?.PendingEvents == null || node.PendingEvents.Count == 0) continue;\n\n                var toRemove = new List<EventInstance>();\n                foreach (var ev in node.PendingEvents)\n                {\n                    if (ev == null) continue;\n                    scanned += 1;\n                    ev.AgeDays += 1;\n\n                    if (!registry.TryGetEvent(ev.EventDefId, out var def)) continue;\n                    int limit = def.autoResolveAfterDays;\n                    if (limit <= 0) continue;\n                    if (ev.AgeDays < limit) continue;\n\n                    toRemove.Add(ev);\n                    removed += 1;\n                    Debug.Log($\"[EventAutoResolve] day={s.Day} nodeId={node.Id} eventDefId={ev.EventDefId} age={ev.AgeDays} limit={limit} reason=AutoResolveAfterDays\");\n                }\n\n                if (toRemove.Count > 0)\n                {\n                    foreach (var ev in toRemove) node.PendingEvents.Remove(ev);\n                }\n            }\n\n            Debug.Log($\"[EventAutoResolve] day={s.Day} scanned={scanned} removed={removed}\");\n        }\n\n        private static bool IsTaskBlockedByEvents(GameState state, NodeState node, NodeTask task, DataRegistry registry)\n        {\n            if (node?.PendingEvents == null || node.PendingEvents.Count == 0) return false;\n\n            foreach (var ev in node.PendingEvents)\n            {\n                if (ev == null) continue;\n                if (!registry.TryGetEvent(ev.EventDefId, out var def)) continue;\n                if (!DataRegistry.TryParseBlockPolicy(def.blockPolicy, out var policy, out _)) continue;\n\n                if (policy == BlockPolicy.BlockAllTasksOnNode) return true;\n                if (policy == BlockPolicy.BlockOriginTask && !string.IsNullOrEmpty(ev.SourceTaskId) && ev.SourceTaskId == task.Id)\n                    return true;\n            }\n\n            return false;\n        }\n\n        private static void AddEventToNode(NodeState node, EventInstance ev)\n        {\n            if (node.PendingEvents == null) node.PendingEvents = new List<EventInstance>();\n            node.PendingEvents.Add(ev);\n        }\n\n        private static void AddNewsToLog(GameState s, NewsInstance news)\n        {\n            if (s.NewsLog == null) s.NewsLog = new List<NewsInstance>();\n            s.NewsLog.Add(news);\n        }\n\n        private static List<AffectScope> ResolveAffects(EventDef eventDef, EventOptionDef optionDef, DataRegistry registry)\n        {\n            if (optionDef?.affects != null && optionDef.affects.Count > 0 &&\n                DataRegistry.TryParseAffectScopes(optionDef.affects, out var optionScopes, out _))\n            {\n                return optionScopes;\n            }\n\n            return GetDefaultAffects(eventDef);\n        }\n\n        private static List<AffectScope> GetDefaultAffects(EventDef eventDef)\n        {\n            if (eventDef?.defaultAffects != null && eventDef.defaultAffects.Count > 0 &&\n                DataRegistry.TryParseAffectScopes(eventDef.defaultAffects, out var scopes, out _))\n            {\n                return scopes;\n            }\n\n            return new List<AffectScope> { new(AffectScopeKind.Node) };\n        }\n\n        private static string BuildEffectSummary(string effectId, IReadOnlyCollection<AffectScope> affects)\n        {\n            if (string.IsNullOrEmpty(effectId)) return string.Empty;\n            var registry = DataRegistry.Instance;\n            if (!registry.EffectOpsByEffectId.TryGetValue(effectId, out var ops) || ops == null || ops.Count == 0)\n                return string.Empty;\n\n            HashSet<string> allowed = affects != null && affects.Count > 0\n                ? new HashSet<string>(affects.Select(a => a.Raw))\n                : null;\n\n            var parts = new List<string>();\n            foreach (var op in ops)\n            {\n                if (op == null) continue;\n                if (allowed != null && !allowed.Contains(op.Scope.Raw)) continue;\n\n                string label = op.StatKey switch\n                {\n                    var k when string.Equals(k, \"LocalPanic\", StringComparison.OrdinalIgnoreCase) => \"本地恐慌\",\n                    var k when string.Equals(k, \"Population\", StringComparison.OrdinalIgnoreCase) => \"人口\",\n                    var k when string.Equals(k, \"WorldPanic\", StringComparison.OrdinalIgnoreCase) || string.Equals(k, \"Panic\", StringComparison.OrdinalIgnoreCase) => \"全局恐慌\",\n                    var k when string.Equals(k, \"Money\", StringComparison.OrdinalIgnoreCase) => \"资金\",\n                    var k when string.Equals(k, \"NegEntropy\", StringComparison.OrdinalIgnoreCase) => \"负熵\",\n                    var k when string.Equals(k, \"TaskProgressDelta\", StringComparison.OrdinalIgnoreCase) => \"任务进度\",\n                    _ => op.StatKey,\n                };\n\n                string scopeLabel = op.Scope.Kind switch\n                {\n                    AffectScopeKind.Node => string.Empty,\n                    AffectScopeKind.Global => \"(全局)\",\n                    AffectScopeKind.OriginTask => \"(来源任务)\",\n                    AffectScopeKind.TaskType when op.Scope.TaskType.HasValue => $\"(任务类型:{op.Scope.TaskType.Value})\",\n                    _ => string.Empty,\n                };\n\n                string valueLabel = op.Op == EffectOpType.Set\n                    ? $\"={op.Value:+0;-0;0}\"\n                    : $\"{(op.Value >= 0 ? \"+\" : string.Empty)}{op.Value:0}\";\n\n                parts.Add($\"{label}{scopeLabel} {valueLabel}\");\n            }\n\n            return parts.Count == 0 ? string.Empty : string.Join(\"，\", parts);\n        }\n\n        private static List<EventDef> GetRandomDailyMatches(\n            IReadOnlyList<EventDef> candidates,\n            int day,\n            string nodeId,\n            string taskTypeKey,\n            string anomalyId,\n            Dictionary<string, int> firedCounts,\n            Dictionary<string, int> lastFiredDay,\n            bool requireAnomalyAny)\n        {\n            var matched = new List<EventDef>();\n            if (candidates == null || candidates.Count == 0) return matched;\n\n            foreach (var ev in candidates)\n            {\n                if (ev == null || string.IsNullOrEmpty(ev.eventDefId)) continue;\n                if (ev.weight <= 0) continue;\n                if (!IsWithinDayWindow(ev, day)) continue;\n                if (!RequirementMatches(ev.requiresNodeId, nodeId)) continue;\n                if (!RequirementMatches(ev.requiresTaskType, taskTypeKey)) continue;\n\n                if (requireAnomalyAny)\n                {\n                    if (!IsRequirementAny(ev.requiresAnomalyId)) continue;\n                }\n                else\n                {\n                    if (!IsRequirementAny(ev.requiresAnomalyId))\n                    {\n                        if (string.IsNullOrEmpty(anomalyId)) continue;\n                        if (!string.Equals(ev.requiresAnomalyId, anomalyId, StringComparison.OrdinalIgnoreCase)) continue;\n                    }\n                }\n\n                if (ev.limitNum > 0 && firedCounts.TryGetValue(ev.eventDefId, out var fired) && fired >= ev.limitNum)\n                    continue;\n\n                if (ev.cd > 0 && lastFiredDay.TryGetValue(ev.eventDefId, out var lastDay) && day - lastDay < ev.cd)\n                    continue;\n\n                matched.Add(ev);\n            }\n\n            return matched;\n        }\n\n        private static List<NewsDef> GetRandomDailyNewsMatches(\n            IReadOnlyList<NewsDef> candidates,\n            int day,\n            string nodeId,\n            string anomalyId,\n            Dictionary<string, int> firedCounts,\n            Dictionary<string, int> lastFiredDay,\n            bool requireAnomalyAny)\n        {\n            var matched = new List<NewsDef>();\n            if (candidates == null || candidates.Count == 0) return matched;\n\n            foreach (var news in candidates)\n            {\n                if (news == null || string.IsNullOrEmpty(news.newsDefId)) continue;\n                if (news.weight <= 0) continue;\n                if (!IsWithinDayWindow(news, day)) continue;\n                if (!RequirementMatches(news.requiresNodeId, nodeId)) continue;\n\n                if (requireAnomalyAny)\n                {\n                    if (!IsRequirementAny(news.requiresAnomalyId)) continue;\n                }\n                else\n                {\n                    if (!IsRequirementAny(news.requiresAnomalyId))\n                    {\n                        if (string.IsNullOrEmpty(anomalyId)) continue;\n                        if (!string.Equals(news.requiresAnomalyId, anomalyId, StringComparison.OrdinalIgnoreCase)) continue;\n                    }\n                }\n\n                if (news.limitNum > 0 && firedCounts.TryGetValue(news.newsDefId, out var fired) && fired >= news.limitNum)\n                    continue;\n\n                if (news.cd > 0 && lastFiredDay.TryGetValue(news.newsDefId, out var lastDay) && day - lastDay < news.cd)\n                    continue;\n\n                matched.Add(news);\n            }\n\n            return matched;\n        }\n\n        private static bool TryPickWeighted(IReadOnlyList<EventDef> candidates, Random rng, out EventDef picked)\n        {\n            picked = null;\n            if (candidates == null || candidates.Count == 0) return false;\n\n            int totalWeight = 0;\n            foreach (var ev in candidates)\n            {\n                if (ev == null || ev.weight <= 0) continue;\n                totalWeight += ev.weight;\n            }\n\n            if (totalWeight <= 0) return false;\n\n            int roll = rng.Next(totalWeight);\n            foreach (var ev in candidates)\n            {\n                if (ev == null || ev.weight <= 0) continue;\n                roll -= ev.weight;\n                if (roll < 0)\n                {\n                    picked = ev;\n                    return true;\n                }\n            }\n\n            picked = candidates.FirstOrDefault(ev => ev != null && ev.weight > 0);\n            return picked != null;\n        }\n\n        private static bool TryPickWeightedNews(IReadOnlyList<NewsDef> candidates, Random rng, out NewsDef picked)\n        {\n            picked = null;\n            if (candidates == null || candidates.Count == 0) return false;\n\n            int totalWeight = 0;\n            foreach (var news in candidates)\n            {\n                if (news == null || news.weight <= 0) continue;\n                totalWeight += news.weight;\n            }\n\n            if (totalWeight <= 0) return false;\n\n            int roll = rng.Next(totalWeight);\n            foreach (var news in candidates)\n            {\n                if (news == null || news.weight <= 0) continue;\n                roll -= news.weight;\n                if (roll < 0)\n                {\n                    picked = news;\n                    return true;\n                }\n            }\n\n            picked = candidates.FirstOrDefault(news => news != null && news.weight > 0);\n            return picked != null;\n        }\n\n        private static void UpdateEventFireTracking(int day, string eventDefId, Dictionary<string, int> firedCounts, Dictionary<string, int> lastFiredDay)\n        {\n            if (string.IsNullOrEmpty(eventDefId)) return;\n            if (firedCounts != null)\n            {\n                firedCounts.TryGetValue(eventDefId, out var fired);\n                firedCounts[eventDefId] = fired + 1;\n            }\n\n            lastFiredDay?.TryGetValue(eventDefId, out _);\n            if (lastFiredDay != null) lastFiredDay[eventDefId] = day;\n        }\n\n        private static void UpdateNewsFireTracking(int day, string newsDefId, Dictionary<string, int> firedCounts, Dictionary<string, int> lastFiredDay)\n        {\n            if (string.IsNullOrEmpty(newsDefId)) return;\n            if (firedCounts != null)\n            {\n                firedCounts.TryGetValue(newsDefId, out var fired);\n                firedCounts[newsDefId] = fired + 1;\n            }\n\n            lastFiredDay?.TryGetValue(newsDefId, out _);\n            if (lastFiredDay != null) lastFiredDay[newsDefId] = day;\n        }\n\n        private static bool IsWithinDayWindow(EventDef def, int day)\n        {\n            if (def == null) return false;\n            if (def.minDay > 0 && day < def.minDay) return false;\n            if (def.maxDay > 0 && day > def.maxDay) return false;\n            return true;\n        }\n\n        private static bool IsWithinDayWindow(NewsDef def, int day)"
        },
        {
            "id": 4,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Data;\nusing UnityEngine;\n\nnamespace Core\n{\n    public static class NewsGenerator\n    {\n        public static void EnsureBootstrapNews(GameState state, DataRegistry data)\n        {\n            if (state == null || data == null) return;\n\n            int day = state.Day;\n            if (day != 1) return;\n\n            state.NewsLog ??= new List<NewsInstance>();\n            var existing = new HashSet<string>(state.NewsLog.Where(n => n != null).Select(n => n.NewsDefId), StringComparer.OrdinalIgnoreCase);\n\n            var defs = data.NewsDefs ?? new List<NewsDef>();\n            var bootstrapDefs = defs\n                .Where(def => def != null &&\n                              string.Equals(def.source, \"Bootstrap\", StringComparison.OrdinalIgnoreCase) &&\n                              (def.minDay <= 0 || day >= def.minDay) &&\n                              (def.maxDay <= 0 || day <= def.maxDay))\n                .ToList();\n\n            if (bootstrapDefs.Count == 0) return;\n\n            int created = 0;\n            foreach (var def in bootstrapDefs)\n            {\n                if (def == null || string.IsNullOrEmpty(def.newsDefId)) continue;\n                if (existing.Contains(def.newsDefId)) continue;\n\n                string nodeId = ResolveBootstrapNodeId(state, def.requiresNodeId);\n                if (string.Equals(def.requiresNodeId, \"START\", StringComparison.OrdinalIgnoreCase))\n                {\n                    Debug.Log($\"[NewsGen] bind START newsDefId={def.newsDefId} nodeId={nodeId}\");\n                }\n\n                var instance = NewsInstanceFactory.Create(def.newsDefId, nodeId, null, \"Bootstrap\");\n                state.NewsLog.Add(instance);\n                existing.Add(def.newsDefId);\n                created += 1;\n            }\n\n            Debug.Log($\"[NewsGen] bootstrap day=1 created={created}\");\n        }\n\n        private static string ResolveBootstrapNodeId(GameState state, string requiresNodeId)\n        {\n            if (state?.Nodes == null || state.Nodes.Count == 0) return null;\n\n            if (string.IsNullOrEmpty(requiresNodeId) || string.Equals(requiresNodeId, \"ANY\", StringComparison.OrdinalIgnoreCase))\n            {\n                return state.Nodes[0].Id;\n            }\n\n            if (string.Equals(requiresNodeId, \"START\", StringComparison.OrdinalIgnoreCase))\n            {\n                return state.Nodes[0].Id;\n            }\n\n            return requiresNodeId;\n        }\n    }\n}"
        },
        {
            "id": 5,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "using System;\n\nnamespace Core\n{\n    [Serializable]\n    public class NewsInstance\n    {\n        public string Id;\n        public string NewsDefId;\n        public string NodeId;\n        public string SourceAnomalyId;\n        // NOTE: SourceAnomalyId is anomalyDefId (e.g., AN_002)\n        public string SourceAnomalyDefId\n        {\n            get => SourceAnomalyId;\n            set => SourceAnomalyId = value;\n        }\n        public string CauseType;\n        public int AgeDays;\n        public bool IsResolved;\n        public int ResolvedDay;\n    }\n\n    public static class NewsInstanceFactory\n    {\n        public static NewsInstance Create(string newsDefId, string nodeId, string sourceAnomalyId, string causeType)\n        {\n            return new NewsInstance\n            {\n                Id = $\"NEWS_{Guid.NewGuid():N}\",\n                NewsDefId = newsDefId,\n                NodeId = nodeId,\n                SourceAnomalyId = sourceAnomalyId,\n                CauseType = causeType,\n                AgeDays = 0,\n                IsResolved = false,\n                ResolvedDay = 0,\n            };\n        }\n    }\n}"
        },
        {
            "id": 6,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": "// Canvas-maintained file: Core/GameState (v3 - N tasks)\n// Source target: Assets/Scripts/Core/GameState.cs\n// Goal: Support unlimited per-node tasks (investigate/contain) via NodeState.Tasks.\n// Notes:\n// - Legacy single-task fields are kept temporarily for compatibility with existing UI/code.\n// - New systems should only use NodeState.Tasks.\n// <EXPORT_BLOCK>\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace Core\n{\n    // Keep for legacy UI and map display. In N-task model, task state is derived from NodeState.Tasks.\n    public enum NodeStatus { Calm, Secured }\n\n    // Legacy event kind (PendingEvent). New node events use EventInstance.\n    public enum EventKind { Investigate, Contain }\n\n    public enum TaskType { Investigate, Contain, Manage }\n    public enum TaskState { Active, Completed, Cancelled }\n\n    [Serializable]\n    public class AgentState\n    {\n        public string Id;\n        public string Name;\n\n        public int Perception = 5;\n        public int Operation = 5;\n        public int Resistance = 5;\n        public int Power = 5;\n        public int HP = 10;\n        public int MaxHP = 10;\n        public int SAN = 10;\n        public int MaxSAN = 10;\n        public int Level = 1;\n        public int Exp = 0;\n        public int TalentPoints = 0;\n    }\n\n    [Serializable]\n    public class RecruitCandidate\n    {\n        public string cid;\n        public AgentState agent;\n        public int cost;\n        public bool isHired;\n        public string hiredAgentId;\n        public string hiredName;\n    }\n\n    [Serializable]\n    public class RecruitPoolState\n    {\n        public int day = -1;\n        public int refreshUsedToday = 0;\n        public List<RecruitCandidate> candidates = new();\n    }\n\n\n    // 收容后进入“已收藏异常”，可被分配干员进行长期管理，按天产出负熵。\n    [Serializable]\n    public class ManagedAnomalyState\n    {\n        public string Id;\n        public string Name;\n        public int Level = 1;\n        public string AnomalyId;\n        public string AnomalyClass;\n\n        // 左侧“已收藏异常”列表使用（后续可做收藏/取消收藏筛选）\n        public bool Favorited = true;\n\n        // 第一次开始管理的日期（用于统计/成长）\n        public int StartDay;\n\n        // 累计产出\n        public int TotalNegEntropy;\n    }\n\n    [Serializable]\n    public class NodeTask\n    {\n        public string Id;\n        public TaskType Type;\n        public TaskState State = TaskState.Active;\n        public string TaskDefId;\n\n        // 0..1\n        public float Progress = 0f;\n\n        // 预定占用：progress==0 也算占用。\n        public List<string> AssignedAgentIds = new();\n\n        // Only for containment tasks: which containable we are trying to contain.\n        public string TargetContainableId;\n\n        // Investigate: which news clue we are targeting (empty => generic investigation).\n        public string TargetNewsId;\n\n        // Investigate/Contain: anomaly id associated with this task (optional).\n        public string SourceAnomalyId;\n\n        // Only for management tasks: which managed anomaly we are managing.\n        public string TargetManagedAnomalyId;\n\n        public int CreatedDay;\n        public int CompletedDay;\n\n        public bool IsStarted => Progress > 0.0001f;\n    }\n\n    [Serializable]\n    public class NodeState\n    {\n        public string Id;\n        public string Name;\n        public List<string> Tags = new();\n\n        // 0..1 百分比坐标：左下(0,0) 右上(1,1)\n        public float X;\n        public float Y;\n\n        // Node-level status is now coarse. Tasks are in Tasks list.\n        public NodeStatus Status = NodeStatus.Calm;\n\n        public bool HasAnomaly = false;\n        public int AnomalyLevel = 0;\n        public List<string> ActiveAnomalyIds = new();\n        // 已发现/已知异常（Investigate 完成后写入）；口径为 anomalyDefId（如 AN_002）\n        public List<string> KnownAnomalyDefIds = new();\n\n\n        // 收容产出：已收容目标列表（收容完成后写入）\n        public List<ManagedAnomalyState> ManagedAnomalies = new List<ManagedAnomalyState>();\n\n\n        // ===== NEW: Unlimited tasks =====\n        public List<NodeTask> Tasks = new();\n\n        // ===== Node-scoped state =====\n        public int LocalPanic = 0;\n        public int Population = 10;\n        public List<EventInstance> PendingEvents = new();\n        public bool HasPendingEvent => PendingEvents != null && PendingEvents.Count > 0;\n\n        // ===== Legacy fields (temporary) =====\n        // Kept so existing UI/code can compile during migration. Do not use for new features.\n        public List<string> AssignedAgentIds = new List<string>(); // legacy squad\n        public float InvestigateProgress = 0f; // legacy 0..1\n        public float ContainProgress = 0f;     // legacy 0..1\n    }\n\n    [Serializable]\n    public class DecisionOption\n    {\n        public string Id;\n        public string Text;\n\n        // \"Perception\" / \"Operation\" / \"Resistance\" / \"Power\"\n        public string CheckAttr;\n        public int Threshold;\n        public float BaseSuccess = 0.5f;\n\n        public int MoneyOnSuccess = 0;\n        public int MoneyOnFail = 0;\n        public int PanicOnSuccess = 0;\n        public int PanicOnFail = 0;\n\n        public float ProgressDeltaOnSuccess = 0.02f;\n        public float ProgressDeltaOnFail = -0.06f;\n    }\n\n    [Serializable]\n    public class PendingEvent\n    {\n        public string Id;\n        public string NodeId;\n        public EventKind Kind;\n\n        public string Title;\n        public string Desc;\n\n        public List<DecisionOption> Options = new();\n    }\n\n    [Serializable]\n    public class GameState\n    {\n        public int Day = 1;\n        public int Money = 0;\n        public float WorldPanic = 0f;\n\n        // 预留字段：Intel（暂不结算）\n        public int Intel = 0;\n\n        // 新货币：负熵（由“管理异常”系统每日产出）\n        public int NegEntropy = 0;\n\n        // 已收藏/已收容异常的长期管理状态（Legacy/Deprecated）\n        // Node-scoped source of truth is NodeState.ManagedAnomalies.\n        public List<ManagedAnomalyState> ManagedAnomalies = new List<ManagedAnomalyState>();\n\n        public List<NodeState> Nodes = new();\n        public List<AgentState> Agents = new();\n\n        public List<PendingEvent> PendingEvents = new();\n        public List<string> News = new();\n        public List<NewsInstance> NewsLog = new();\n\n        public Dictionary<string, int> EventFiredCounts = new();\n        public Dictionary<string, int> EventLastFiredDay = new();\n        public Dictionary<string, int> NewsFiredCounts = new();\n        public Dictionary<string, int> NewsLastFiredDay = new();\n\n        public RecruitPoolState RecruitPool = new RecruitPoolState();\n    }\n}\n// </EXPORT_BLOCK>"
        },
        {
            "id": 7,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        },
        {
            "id": 8,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        },
        {
            "id": 9,
            "status": "success",
            "error": "",
            "changed": false,
            "resolved_target": "",
            "data": ""
        }
    ]
}